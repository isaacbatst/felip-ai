<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Dashboard - Configurações de Milhas</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/public/output.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  <script defer src="https://unpkg.com/alpinejs@3.13.3/dist/cdn.min.js"></script>
</head>

<body x-data="dashboard()" x-init="init()" x-cloak class="font-sans bg-white md:bg-gradient-to-br md:from-primary md:to-secondary min-h-screen p-5 max-md:p-0 ">
  <!-- Loading Overlay -->
  <div class="fixed inset-0 bg-white/90 flex items-center justify-center z-[1000]" x-show="loading || errorMessage">
    <div class="text-center" x-show="loading && !errorMessage">
      <div class="spinner" style="width: 40px; height: 40px; border-width: 4px;"></div>
      <p class="mt-4 text-gray-500">Carregando...</p>
    </div>
    <div class="text-center p-10" x-show="errorMessage">
      <div class="mb-4"><i class="fa-solid fa-triangle-exclamation w-12 h-12 text-red-800"></i></div>
      <h2 class="text-red-800 mb-2 text-lg font-semibold">Link Inválido</h2>
      <p class="text-gray-500" x-text="errorMessage"></p>
    </div>
  </div>

  <div class="bg-white p-8 rounded-2xl shadow-2xl max-w-4xl mx-auto max-md:p-4 max-md:rounded-none max-md:shadow-none" x-show="!loading && !errorMessage">
    <div class="flex justify-between items-center mb-4 pb-5 border-b-2 border-gray-100 max-md:pb-4 max-md:mb-0">
      <h1 class="text-gray-800 text-2xl font-semibold max-md:text-xl">Dashboard</h1>
      <button @click="logout()"
        :disabled="loggingOut"
        class="px-4 py-2 rounded-lg text-sm whitespace-nowrap transition-all bg-gray-100 text-gray-600 hover:bg-gray-200 cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed">
        <i class="fa-solid fa-right-from-bracket mr-1"></i>
        <span x-show="!loggingOut">Sair</span>
        <span x-show="loggingOut">Saindo...</span>
      </button>
    </div>
    
    <!-- Bot Status Toggle + Worker Status -->
    <div class="bg-white border border-gray-200 rounded-xl p-4 mb-5 max-md:mx-0 max-md:rounded-none max-md:border-x-0 max-md:border-t-0">
      <div class="flex items-center justify-between">
        <div class="flex items-center gap-3">
          <div class="w-10 h-10 shrink-0 rounded-full flex items-center justify-center"
            :class="getWorkerIndicatorClass()">
            <i class="fa-solid" :class="getWorkerIndicatorIcon()"></i>
          </div>
          <div>
            <h4 class="font-semibold text-sm text-gray-800 mb-0.5">Bot <span :class="botStatus.isEnabled ? 'text-emerald-600' : 'text-gray-500'" x-text="botStatus.isEnabled ? 'Ativado' : 'Desativado'"></span></h4>
            <p class="text-xs text-gray-500" x-text="getWorkerStatusText()"></p>
          </div>
        </div>
        <div class="flex items-center gap-2">
          <label class="relative inline-flex items-center cursor-pointer">
            <input type="checkbox" class="sr-only peer" x-model="botStatus.isEnabled" @change="handleToggle()" :disabled="savingBotStatus">
            <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-primary/20 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-emerald-500 peer-disabled:opacity-50"></div>
          </label>
        </div>
      </div>

      <!-- Auth Code Input -->
      <div x-show="getConnectionStatus() === 'needsCode'" class="mt-4 pt-4 border-t border-gray-100">
        <div class="bg-blue-50 border border-blue-100 rounded-lg p-3 mb-3">
          <p class="text-sm text-gray-700 mb-1">
            <i class="fa-solid fa-shield-halved text-primary mr-1"></i>
            <strong>Precisamos conectar ao seu Telegram</strong>
          </p>
          <p class="text-xs text-gray-500 leading-relaxed">
            Para que o bot responda automaticamente nos grupos, ele precisa acessar sua conta do Telegram.
            O Telegram enviou um <strong>codigo de verificacao</strong> para voce &mdash; digite-o abaixo para autorizar a conexao.
          </p>
          <p class="text-xs text-gray-400 mt-1.5 flex items-center gap-1">
            <i class="fa-solid fa-lock text-xs"></i>
            Suas credenciais sao usadas apenas para a conexao e nao ficam armazenadas.
          </p>
        </div>
        <form @submit.prevent="submitAuthCode()" class="flex gap-2 flex-col md:flex-row">
          <input type="text" inputmode="numeric" maxlength="8" x-model="authCode"
            placeholder="Codigo do Telegram"
            class="flex-1 p-3 border border-gray-200 rounded-lg text-base text-center tracking-widest font-mono transition-all focus:border-primary focus:ring-2 focus:ring-primary/20 outline-none"
            :disabled="submittingAuth">
          <button type="submit"
            class="flex items-center justify-center gap-2 px-5 py-3 bg-primary text-white font-semibold rounded-lg transition-all hover:bg-primary/90 disabled:opacity-50 disabled:cursor-not-allowed"
            :disabled="submittingAuth || authCode.length < 4">
            <span x-show="submittingAuth" class="spinner" style="width: 16px; height: 16px; border-width: 2px;"></span>
            <span x-text="submittingAuth ? 'Enviando...' : 'Enviar'"></span>
          </button>
        </form>
      </div>

      <!-- Password Input -->
      <div x-show="getConnectionStatus() === 'needsPassword'" class="mt-4 pt-4 border-t border-gray-100">
        <div class="bg-blue-50 border border-blue-100 rounded-lg p-3 mb-3">
          <p class="text-sm text-gray-700 mb-1">
            <i class="fa-solid fa-lock text-primary mr-1"></i>
            <strong>Verificacao em duas etapas</strong>
          </p>
          <p class="text-xs text-gray-500 leading-relaxed">
            Sua conta do Telegram possui verificacao em duas etapas ativada &mdash; otimo, isso significa que ela esta bem protegida!
            Digite sua <strong>senha do Telegram</strong> (a senha de nuvem / cloud password) para concluir a conexao.
          </p>
          <p class="text-xs text-gray-400 mt-1.5 flex items-center gap-1">
            <i class="fa-solid fa-lock text-xs"></i>
            A senha e usada somente para autenticar a conexao e nao fica armazenada.
          </p>
        </div>
        <form @submit.prevent="submitPassword()" class="flex gap-2 flex-col md:flex-row">
          <input type="password" x-model="authPassword"
            placeholder="Senha do Telegram"
            class="flex-1 p-3 border border-gray-200 rounded-lg text-base transition-all focus:border-primary focus:ring-2 focus:ring-primary/20 outline-none"
            :disabled="submittingAuth">
          <button type="submit"
            class="flex items-center justify-center gap-2 px-5 py-3 bg-primary text-white font-semibold rounded-lg transition-all hover:bg-primary/90 disabled:opacity-50 disabled:cursor-not-allowed"
            :disabled="submittingAuth || authPassword.length === 0">
            <span x-show="submittingAuth" class="spinner" style="width: 16px; height: 16px; border-width: 2px;"></span>
            <span x-text="submittingAuth ? 'Enviando...' : 'Enviar'"></span>
          </button>
        </form>
      </div>

      <!-- Error / Disconnected State -->
      <div x-show="getConnectionStatus() === 'error'" class="mt-4 pt-4 border-t border-gray-100">
        <div class="bg-red-50 border border-red-100 rounded-lg p-3 mb-3">
          <div class="flex items-center gap-2 text-red-600 mb-1">
            <i class="fa-solid fa-plug-circle-xmark"></i>
            <span class="text-sm font-medium">Conexao com o Telegram perdida</span>
          </div>
          <p class="text-xs text-gray-500">Isso pode acontecer por instabilidade na rede ou inatividade. Clique abaixo para reconectar — pode ser necessario informar o codigo novamente.</p>
        </div>
        <button @click="reconnectWorker()"
          class="flex items-center gap-2 px-4 py-2 text-sm font-medium rounded-lg bg-red-100 text-red-600 hover:bg-red-200 transition-all disabled:opacity-50 disabled:cursor-not-allowed"
          :disabled="reconnecting">
          <span x-show="reconnecting" class="spinner" style="width: 14px; height: 14px; border-width: 2px;"></span>
          <i x-show="!reconnecting" class="fa-solid fa-plug"></i>
          <span x-text="reconnecting ? 'Reconectando...' : 'Reconectar'"></span>
        </button>
      </div>
    </div>

    <!-- Section Tabs -->
    <div class="section-tabs flex justify-center gap-0 mb-5 border-b-2 border-gray-100 flex-wrap max-md:gap-1 max-md:justify-start max-md:border-b-0">
      <button class="px-5 py-3 border-none bg-transparent cursor-pointer text-sm font-medium border-b-3 -mb-0.5 transition-all flex flex-col gap-1 hover:text-primary max-md:px-3 max-md:py-2 max-md:flex-row max-md:items-center max-md:rounded-full max-md:border-0 max-md:mb-0" :class="activeSection === 'prices' ? 'text-primary border-b-primary max-md:bg-primary/10' : 'text-gray-500 border-transparent max-md:bg-gray-100'" @click="activeSection = 'prices'">
        <i class="fa-solid fa-chart-simple"></i> Preços
      </button>
      <button class="px-5 py-3 border-none bg-transparent cursor-pointer text-sm font-medium border-b-3 -mb-0.5 transition-all flex flex-col gap-1 hover:text-primary max-md:px-3 max-md:py-2 max-md:flex-row max-md:items-center max-md:rounded-full max-md:border-0 max-md:mb-0" :class="activeSection === 'limits' ? 'text-primary border-b-primary max-md:bg-primary/10' : 'text-gray-500 border-transparent max-md:bg-gray-100'"
        @click="activeSection = 'limits'">
        <i class="fa-solid fa-sliders"></i> Limites
      </button>
      <button class="px-5 py-3 border-none bg-transparent cursor-pointer text-sm font-medium border-b-3 -mb-0.5 transition-all flex flex-col gap-1 hover:text-primary max-md:px-3 max-md:py-2 max-md:flex-row max-md:items-center max-md:rounded-full max-md:border-0 max-md:mb-0" :class="activeSection === 'counterOffer' ? 'text-primary border-b-primary max-md:bg-primary/10' : 'text-gray-500 border-transparent max-md:bg-gray-100'" @click="activeSection = 'counterOffer'">
        <i class="fa-solid fa-message"></i> Proposta
      </button>
      <button class="px-5 py-3 border-none bg-transparent cursor-pointer text-sm font-medium border-b-3 -mb-0.5 transition-all flex flex-col gap-1 hover:text-primary max-md:px-3 max-md:py-2 max-md:flex-row max-md:items-center max-md:rounded-full max-md:border-0 max-md:mb-0" :class="activeSection === 'groups' ? 'text-primary border-b-primary max-md:bg-primary/10' : 'text-gray-500 border-transparent max-md:bg-gray-100'" @click="activeSection = 'groups'; fetchGroupsIfNeeded()">
        <i class="fa-solid fa-users"></i> Grupos
      </button>
      <button class="px-5 py-3 border-none bg-transparent cursor-pointer text-sm font-medium border-b-3 -mb-0.5 transition-all flex flex-col gap-1 hover:text-primary max-md:px-3 max-md:py-2 max-md:flex-row max-md:items-center max-md:rounded-full max-md:border-0 max-md:mb-0" :class="activeSection === 'subscription' ? 'text-primary border-b-primary max-md:bg-primary/10' : 'text-gray-500 border-transparent max-md:bg-gray-100'" @click="activeSection = 'subscription'; fetchSubscriptionIfNeeded()">
        <i class="fa-solid fa-credit-card"></i> Assinatura
      </button>
    </div>

    <!-- Price Tables Section -->
    <div class="section mb-8 p-5 bg-gray-50 rounded-xl max-md:p-0 max-md:mb-6" x-show="activeSection === 'prices'">
      <div class="section-header flex justify-between items-center mb-4 max-md:mx-3 max-md:py-3 max-md:border-b max-md:border-gray-200">
        <h2 class="text-gray-800 text-lg font-semibold flex items-center gap-1 max-md:text-base"><i class="fa-solid fa-chart-simple"></i> Tabela de Preços</h2>
      </div>
      <p class="section-description text-gray-500 text-sm mb-4">
        Configure os preços por quantidade (em milhares). Ex: 15 = 15k milhas
      </p>

      <!-- Program Tabs -->
      <div class="flex gap-2 mb-4 flex-wrap max-md:mx-3">
        <template x-for="p in normalPrograms" :key="p.id">
          <button class="px-4 py-2 border-2 rounded-lg cursor-pointer text-sm font-medium transition-all" 
            :class="selectedProgramId === p.id ? 'bg-linear-135 from-primary to-secondary text-white border-transparent' : 'border-gray-200 bg-white hover:border-primary hover:text-primary'" 
            @click="selectProgram(p.id)"
            x-text="p.name">
          </button>
        </template>
      </div>

      <!-- Price Type Tabs (only when has liminar) -->
      <div class="price-type-tabs flex gap-0 mb-4 bg-gray-100 rounded-lg p-1 max-w-xs max-md:mx-3" x-show="hasLiminar()">
        <button class="flex-1 px-4 py-2.5 border-none rounded-md text-sm font-medium cursor-pointer transition-all hover:text-primary" :class="priceTypeTab === 'normal' ? 'bg-white text-primary shadow-sm' : 'bg-transparent text-gray-500'"
          @click="priceTypeTab = 'normal'">
          Normal
        </button>
        <button class="flex-1 px-4 py-2.5 border-none rounded-md text-sm font-medium cursor-pointer transition-all hover:text-primary" :class="priceTypeTab === 'liminar' ? 'bg-white text-primary shadow-sm' : 'bg-transparent text-gray-500'"
          @click="priceTypeTab = 'liminar'">
          Liminar
        </button>
      </div>

      <template x-for="prog in programsToShow" :key="prog.id">
          <div class="price-carousel-wrapper relative flex flex-col gap-3 mb-4" x-show="shouldShowPriceProgram(prog)">
            <h4 class="text-sm mb-3 text-gray-800" x-show="!hasLiminar()">
              <span x-text="prog.name"></span>
              <span x-show="prog.isLiminar" class="inline-block py-0.5 px-2 bg-amber-100 text-amber-700 rounded text-[11px] font-semibold ml-2">LIMINAR</span>
            </h4>

            <!-- Price Cards -->
            <template x-if="getPriceEntries(prog.id).length > 0">
              <div class="price-cards-list flex flex-col gap-3">
                <template x-for="(entry, i) in getPriceEntries(prog.id)" :key="i">
                  <div class="data-card price-data-card bg-white border border-gray-200 rounded-xl p-4 relative transition-all hover:shadow-md hover:border-gray-300" :data-program-id="prog.id">
                    <div class="data-card-header flex justify-between items-center mb-3">
                      <span class="bg-linear-135 from-primary to-secondary text-white px-3 py-1 rounded-xl text-sm font-semibold" x-text="`${entry.quantity || 0}k`"></span>
                      <div class="data-card-actions flex gap-2 items-center">
                        <button class="data-card-delete w-8 h-8 rounded-full border-none bg-red-100 text-red-600 text-base cursor-pointer flex items-center justify-center transition-all hover:bg-red-200 hover:scale-110 disabled:opacity-50 disabled:cursor-not-allowed" 
                          @click="removePriceEntry(prog.id, i)"
                          :disabled="deletingEntryIndex === i">
                          <span x-show="deletingEntryIndex === i" class="spinner" style="width: 14px; height: 14px;"></span>
                          <span x-show="deletingEntryIndex !== i"><i class="fa-solid fa-trash"></i></span>
                        </button>
                      </div>
                    </div>
                    <div class="data-card-fields flex gap-3">
                      <div class="data-card-field flex-1">
                        <label class="block text-xs text-gray-500 mb-1.5 font-medium">Quantidade (k)</label>
                        <input type="text" inputmode="numeric" :value="entry.quantity || ''"
                          @input="formatInput($event, false); entry.quantity = parseNumber($event.target.value, false) || 0; markAsChanged()"
                          @focus="editingEntry = entry; editingEntryIndex = i"
                          placeholder="15" class="w-full p-2 md:p-3 border rounded-lg text-base text-center transition-all"
                          :class="entry.quantity > 0 ? 'border-gray-200' : 'border-red-400'">
                      </div>
                      <div class="data-card-field flex-1">
                        <label class="block text-xs text-gray-500 mb-1.5 font-medium">Preço (R$)</label>
                        <input type="text" inputmode="decimal" :value="entry.price || ''"
                          @input="formatInput($event, true); entry.price = parseNumber($event.target.value, true) || 0; markAsChanged()"
                          placeholder="20.00" class="w-full p-2 md:p-3 border rounded-lg text-base text-center transition-all"
                          :class="entry.price > 0 ? 'border-gray-200' : 'border-red-400'">
                      </div>
                    </div>
                  </div>
                </template>
              </div>
            </template>

            <!-- Empty state message -->
            <template x-if="getPriceEntries(prog.id).length === 0">
              <div class="text-center p-5 text-gray-500">
                <p>Nenhum preço cadastrado. Clique em "Adicionar Preço" para começar.</p>
              </div>
            </template>

            <button class="add-card-btn w-full p-4 border-2 border-dashed border-primary rounded-xl bg-transparent text-primary text-base font-semibold cursor-pointer flex items-center justify-center gap-2 mt-3 transition-all hover:bg-primary/5 hover:border-secondary" @click="addPriceEntry(prog.id)">+ Adicionar Preço</button>

            <!-- Ceiling Price (Preço Teto) -->
            <div class="mt-4 p-4 bg-white border border-gray-200 rounded-xl">
              <label class="block text-xs text-gray-500 mb-1.5 font-medium">Preço Teto (R$)</label>
              <input type="text" inputmode="decimal"
                :value="getMaxPrice(prog.id)?.maxPrice || ''"
                @input="formatInput($event, true); updateMaxPrice(prog.id, $event.target.value)"
                placeholder="Sem limite"
                class="w-full p-3 border border-gray-200 rounded-lg text-base text-center transition-all">
            </div>

            <button class="save-program-btn w-full p-4 border-2 border-emerald-500 rounded-xl bg-emerald-50 text-emerald-600 text-base font-semibold cursor-pointer flex items-center justify-center gap-2 mt-3 transition-all hover:bg-emerald-100 disabled:opacity-50 disabled:cursor-not-allowed"
              @click="saveProgramPrices(prog.id)"
              :disabled="savingProgramId === prog.id || !hasValidPricesForProgram(prog.id)">
              <span x-show="savingProgramId === prog.id" class="spinner" style="width: 16px; height: 16px;"></span>
              <span x-show="savingProgramId !== prog.id"><i class="fa-solid fa-floppy-disk"></i> Salvar Preços</span>
            </button>
          </div>
        </template>

    </div>

    <!-- Limits Section (Stock + Minimum Quantity) -->
    <div class="section mb-8 p-5 bg-gray-50 rounded-xl max-md:p-0 max-md:mb-6" x-show="activeSection === 'limits'">
      <div class="section-header flex justify-between items-center mb-4 max-md:mx-3 max-md:py-3 max-md:border-b max-md:border-gray-200">
        <h2 class="text-gray-800 text-lg font-semibold flex items-center gap-1 max-md:text-base"><i class="fa-solid fa-sliders"></i> Limites por Programa</h2>
      </div>
      <p class="section-description text-gray-500 text-sm mb-4">
        Configure estoque de milhas e quantidade mínima por programa
      </p>

      <!-- Program Tabs -->
      <div class="flex gap-2 mb-4 flex-wrap max-md:mx-3">
        <template x-for="p in normalPrograms" :key="p.id">
          <button class="px-4 py-2 border-2 rounded-lg cursor-pointer text-sm font-medium transition-all"
            :class="selectedProgramId === p.id ? 'bg-linear-135 from-primary to-secondary text-white border-transparent' : 'border-gray-200 bg-white hover:border-primary hover:text-primary'"
            @click="selectProgram(p.id)"
            x-text="p.name">
          </button>
        </template>
      </div>

      <div class="data-cards flex flex-col gap-3">
        <template x-for="prog in programsToShow" :key="prog.id">
          <div class="data-card bg-white border border-gray-200 rounded-xl p-4 relative transition-all hover:shadow-md hover:border-gray-300" :data-program-id="prog.id">
            <div class="data-card-header flex justify-between items-center mb-3">
              <span class="data-card-title font-semibold text-sm text-gray-800">
                <span x-text="prog.name"></span>
                <span x-show="prog.isLiminar" class="inline-block py-0.5 px-2 bg-amber-100 text-amber-700 rounded text-[11px] font-semibold ml-2">LIMINAR</span>
              </span>
            </div>
            <div class="data-card-fields flex gap-3">
              <div class="data-card-field flex-1">
                <label class="block text-xs text-gray-500 mb-1.5 font-medium">Milhas Disponíveis</label>
                <input type="text" inputmode="numeric"
                  :value="formatThousands(getMiles(prog.id)?.availableMiles)"
                  @input="formatThousandsInput($event); updateMiles(prog.id, $event.target.value.replace(/\./g, ''))"
                  placeholder="0" class="w-full p-3 border border-gray-200 rounded-lg text-base text-center transition-all">
              </div>
              <div class="data-card-field flex-1">
                <label class="block text-xs text-gray-500 mb-1.5 font-medium">Qtd. Mínima</label>
                <input type="text" inputmode="numeric"
                  :value="formatThousands(getMinQuantity(prog.id))"
                  @input="formatThousandsInput($event); updateMinQuantity(prog.id, $event.target.value.replace(/\./g, ''))"
                  placeholder="Ex: 50.000" class="w-full p-3 border border-gray-200 rounded-lg text-base text-center transition-all">
              </div>
            </div>
          </div>
        </template>
      </div>

      <div class="btn-group flex gap-2.5 justify-end mt-4 max-md:justify-center">
        <button type="button" class="bg-linear-135 from-primary to-secondary px-6 py-3 text-sm font-semibold border-none rounded-lg cursor-pointer transition-all text-white disabled:opacity-60 disabled:cursor-not-allowed hover:not-disabled:-translate-y-0.5 hover:not-disabled:shadow-lg" @click="saveLimits()" :disabled="saving">
          <span x-show="saving" class="spinner mr-2"></span>
          Salvar Limites
        </button>
      </div>
    </div>

    <!-- Counter Offer Section -->
    <div class="section mb-8 p-5 bg-gray-50 rounded-xl max-md:p-0 max-md:mb-6" x-show="activeSection === 'counterOffer'">
      <div class="section-header flex justify-between items-center mb-4 max-md:mx-3 max-md:py-3 max-md:border-b max-md:border-gray-200">
        <h2 class="text-gray-800 text-lg font-semibold flex items-center gap-1 max-md:text-base"><i class="fa-solid fa-message"></i> Proposta Privada</h2>
      </div>
      <p class="section-description text-gray-500 text-sm mb-4">
        Configure as mensagens enviadas no privado do comprador para negociação e fechamento de negócios
      </p>

      <!-- Enable Toggle -->
      <div class="data-card bg-white border border-gray-200 rounded-xl p-4 mb-4">
        <div class="flex items-center justify-between">
          <div>
            <h4 class="font-semibold text-sm text-gray-800 mb-1">Habilitar Mensagens Privadas</h4>
            <p class="text-xs text-gray-500">O bot enviará mensagens no privado para negociar e fechar negócios</p>
          </div>
          <label class="relative inline-flex items-center cursor-pointer">
            <input type="checkbox" class="sr-only peer" x-model="counterOfferSettings.isEnabled" @change="markCounterOfferChanged()">
            <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-primary/20 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary"></div>
          </label>
        </div>
      </div>

      <!-- Sub-abas: Contra-proposta | Fechamento -->
      <div class="flex gap-0 mb-4 bg-gray-100 rounded-lg p-1" :class="{ 'opacity-50': !counterOfferSettings.isEnabled }">
        <button class="flex-1 px-4 py-2.5 border-none rounded-md text-sm font-medium cursor-pointer transition-all hover:text-primary"
          :class="proposalSubTab === 'counterOffer' ? 'bg-white text-primary shadow-sm' : 'bg-transparent text-gray-500'"
          @click="proposalSubTab = 'counterOffer'"
          :disabled="!counterOfferSettings.isEnabled">
          Contra-proposta
        </button>
        <button class="flex-1 px-4 py-2.5 border-none rounded-md text-sm font-medium cursor-pointer transition-all hover:text-primary"
          :class="proposalSubTab === 'callToAction' ? 'bg-white text-primary shadow-sm' : 'bg-transparent text-gray-500'"
          @click="proposalSubTab = 'callToAction'"
          :disabled="!counterOfferSettings.isEnabled">
          Fechamento
        </button>
      </div>

      <!-- Conteúdo da sub-aba Contra-proposta -->
      <div x-show="proposalSubTab === 'counterOffer'">
        <!-- Price Threshold -->
        <div class="data-card bg-white border border-gray-200 rounded-xl p-4 mb-4" :class="{ 'opacity-50': !counterOfferSettings.isEnabled }">
          <div class="data-card-header mb-3">
            <h4 class="font-semibold text-sm text-gray-800">Range de Preço Aceitável</h4>
            <p class="text-xs text-gray-500 mt-1">Se a diferença entre o preço pedido e o seu preço for até este valor, uma proposta será enviada</p>
          </div>
          <div class="flex items-center gap-3">
            <span class="text-gray-500 text-sm">R$</span>
            <input type="text" inputmode="decimal" 
              :value="counterOfferSettings.priceThreshold" 
              @input="formatInput($event, true); counterOfferSettings.priceThreshold = parseNumber($event.target.value, true) || 0; markCounterOfferChanged()"
              :disabled="!counterOfferSettings.isEnabled"
              placeholder="0.50" 
              class="w-32 p-3 border border-gray-200 rounded-lg text-base text-center transition-all disabled:bg-gray-100 disabled:cursor-not-allowed">
            <span class="text-gray-500 text-sm">de diferença</span>
          </div>
          <p class="text-xs text-gray-400 mt-2">Ex: se seu preço é R$ 16,50 e o range é R$ 0,50, propostas serão enviadas para pedidos de R$ 16,00 ou mais</p>
        </div>

        <!-- Counter Offer Message Template -->
        <div class="data-card bg-white border border-gray-200 rounded-xl p-4 mb-4" :class="{ 'opacity-50': !counterOfferSettings.isEnabled }">
          <div class="data-card-header mb-3">
            <h4 class="font-semibold text-sm text-gray-800">Modelo de Mensagem</h4>
            <p class="text-xs text-gray-500 mt-1">Escolha o estilo da mensagem de contra-proposta</p>
          </div>
          <div class="flex flex-col gap-3">
            <template x-for="template in counterOfferTemplates" :key="template.id">
              <label class="flex items-start gap-3 p-3 border rounded-lg cursor-pointer transition-all" 
                :class="counterOfferSettings.messageTemplateId === template.id ? 'border-primary bg-primary/5' : 'border-gray-200 hover:border-gray-300'"
                @click="counterOfferSettings.messageTemplateId = template.id; markCounterOfferChanged()">
                <input type="radio" name="messageTemplate" 
                  :value="template.id" 
                  :checked="counterOfferSettings.messageTemplateId === template.id"
                  :disabled="!counterOfferSettings.isEnabled"
                  class="mt-1">
                <div class="flex-1">
                  <div class="font-medium text-sm text-gray-800" x-text="template.description"></div>
                  <pre class="text-xs text-gray-500 mt-2 whitespace-pre-wrap bg-gray-50 p-2 rounded" x-text="template.preview"></pre>
                </div>
              </label>
            </template>
          </div>
        </div>
      </div>

      <!-- Conteúdo da sub-aba Fechamento -->
      <div x-show="proposalSubTab === 'callToAction'">
        <!-- Call to Action Message Template -->
        <div class="data-card bg-white border border-gray-200 rounded-xl p-4 mb-4" :class="{ 'opacity-50': !counterOfferSettings.isEnabled }">
          <div class="data-card-header mb-3">
            <h4 class="font-semibold text-sm text-gray-800">Modelo de Mensagem</h4>
            <p class="text-xs text-gray-500 mt-1">Escolha o estilo da mensagem de fechamento</p>
          </div>
          <div class="flex flex-col gap-3">
            <template x-for="template in callToActionTemplates" :key="template.id">
              <label class="flex items-start gap-3 p-3 border rounded-lg cursor-pointer transition-all" 
                :class="counterOfferSettings.callToActionTemplateId === template.id ? 'border-primary bg-primary/5' : 'border-gray-200 hover:border-gray-300'"
                @click="counterOfferSettings.callToActionTemplateId = template.id; markCounterOfferChanged()">
                <input type="radio" name="callToActionTemplate" 
                  :value="template.id" 
                  :checked="counterOfferSettings.callToActionTemplateId === template.id"
                  :disabled="!counterOfferSettings.isEnabled"
                  class="mt-1">
                <div class="flex-1">
                  <div class="font-medium text-sm text-gray-800" x-text="template.description"></div>
                  <pre class="text-xs text-gray-500 mt-2 whitespace-pre-wrap bg-gray-50 p-2 rounded" x-text="template.preview"></pre>
                </div>
              </label>
            </template>
          </div>
        </div>
      </div>

      <div class="btn-group flex gap-2.5 justify-end mt-4 max-md:justify-center">
        <button type="button" class="bg-linear-135 from-primary to-secondary px-6 py-3 text-sm font-semibold border-none rounded-lg cursor-pointer transition-all text-white disabled:opacity-60 disabled:cursor-not-allowed hover:not-disabled:-translate-y-0.5 hover:not-disabled:shadow-lg" 
          @click="saveCounterOfferSettings()" 
          :disabled="savingCounterOffer || !counterOfferChanged">
          <span x-show="savingCounterOffer" class="spinner mr-2"></span>
          Salvar Configurações
        </button>
      </div>
    </div>

    <!-- Groups Section -->
    <div class="section mb-8 p-5 bg-gray-50 rounded-xl max-md:p-0 max-md:mb-6" x-show="activeSection === 'groups'">
      <div class="section-header flex justify-between items-center mb-4 max-md:mx-3 max-md:py-3 max-md:border-b max-md:border-gray-200">
        <h2 class="text-gray-800 text-lg font-semibold flex items-center gap-1 max-md:text-base"><i class="fa-solid fa-users"></i> Grupos Ativos</h2>
        <button type="button" 
          class="px-4 py-2 text-sm font-medium rounded-lg border-2 border-primary text-primary bg-white hover:bg-primary/5 transition-all disabled:opacity-50 disabled:cursor-not-allowed"
          @click="fetchAvailableGroups()"
          :disabled="loadingAvailableGroups">
          <span x-show="loadingAvailableGroups" class="spinner mr-2" style="width: 14px; height: 14px;"></span>
          <i x-show="!loadingAvailableGroups" class="fa-solid fa-sync-alt mr-1"></i>
          Atualizar
        </button>
      </div>
      <p class="section-description text-gray-500 text-sm mb-4">
        Selecione os grupos do Telegram onde o bot deve responder às mensagens de compra
      </p>

      <!-- Loading State -->
      <div x-show="loadingGroups" class="text-center p-8">
        <div class="spinner mx-auto mb-4" style="width: 32px; height: 32px; border-width: 3px;"></div>
        <p class="text-gray-500">Carregando grupos...</p>
      </div>

      <!-- Error State -->
      <div x-show="groupsError && !loadingGroups" class="text-center p-8 bg-red-50 rounded-xl">
        <i class="fa-solid fa-triangle-exclamation text-red-500 text-2xl mb-3"></i>
        <p class="text-red-600 font-medium mb-2">Erro ao carregar grupos</p>
        <p class="text-red-500 text-sm" x-text="groupsErrorMessage"></p>
        <button type="button" 
          class="mt-4 px-4 py-2 text-sm font-medium rounded-lg bg-red-100 text-red-600 hover:bg-red-200 transition-all"
          @click="fetchAvailableGroups()">
          <i class="fa-solid fa-redo mr-1"></i> Tentar novamente
        </button>
      </div>

      <!-- Groups List -->
      <div x-show="!loadingGroups && !groupsError" class="flex flex-col gap-3">
        <!-- Active Groups -->
        <template x-if="activeGroups.length > 0">
          <div class="mb-4">
            <h4 class="text-sm font-semibold text-gray-700 mb-3 flex items-center gap-2">
              <span class="w-2 h-2 bg-emerald-500 rounded-full"></span>
              Grupos Ativos (<span x-text="activeGroups.length"></span><span x-show="groupLimit !== null && groupLimit > 0">/<span x-text="groupLimit"></span></span>)
            </h4>
            <div class="flex flex-col gap-2">
              <template x-for="group in activeGroups" :key="group.id">
                <div class="data-card bg-white border-2 border-emerald-200 rounded-xl p-4 relative transition-all hover:shadow-md">
                  <div class="flex items-center justify-between">
                    <div class="flex items-center gap-3">
                      <div class="w-10 h-10 rounded-full bg-emerald-100 text-emerald-600 flex items-center justify-center">
                        <i class="fa-solid fa-users"></i>
                      </div>
                      <div>
                        <div class="font-medium text-gray-800" x-text="group.title"></div>
                        <div class="text-xs text-gray-400" x-text="group.id"></div>
                      </div>
                    </div>
                    <button type="button"
                      class="px-3 py-2 text-sm font-medium rounded-lg bg-red-100 text-red-600 hover:bg-red-200 transition-all disabled:opacity-50 disabled:cursor-not-allowed"
                      @click="deactivateGroup(group.id)"
                      :disabled="deactivatingGroupId === group.id">
                      <span x-show="deactivatingGroupId === group.id" class="spinner" style="width: 14px; height: 14px;"></span>
                      <span x-show="deactivatingGroupId !== group.id"><i class="fa-solid fa-times mr-1"></i> <span class="hidden md:inline">Desativar</span></span>
                    </button>
                  </div>
                </div>
              </template>
            </div>
          </div>
        </template>

        <!-- Empty Active Groups -->
        <template x-if="activeGroups.length === 0 && availableGroups.length > 0">
          <div class="text-center p-6 bg-amber-50 rounded-xl mb-4">
            <i class="fa-solid fa-info-circle text-amber-500 text-xl mb-2"></i>
            <p class="text-amber-700 text-sm">Nenhum grupo ativo. Selecione grupos abaixo para ativar.</p>
          </div>
        </template>

        <!-- Group Limit Warning -->
        <template x-if="isGroupLimitReached && inactiveGroups.length > 0">
          <div class="p-4 bg-amber-50 border border-amber-200 rounded-xl mb-2">
            <div class="flex items-center gap-2">
              <i class="fa-solid fa-triangle-exclamation text-amber-500"></i>
              <p class="text-amber-700 text-sm font-medium">Limite de grupos atingido (<span x-text="activeGroups.length"></span>/<span x-text="groupLimit"></span>). Desative um grupo para ativar outro ou faça upgrade do seu plano.</p>
            </div>
          </div>
        </template>

        <!-- Available Groups -->
        <template x-if="inactiveGroups.length > 0">
          <div>
            <h4 class="text-sm font-semibold text-gray-700 mb-3 flex items-center gap-2">
              <span class="w-2 h-2 bg-gray-300 rounded-full"></span>
              Grupos Disponíveis (<span x-text="inactiveGroups.length"></span>)
            </h4>
            <div class="flex flex-col gap-2">
              <template x-for="group in inactiveGroups" :key="group.id">
                <div class="data-card bg-white border border-gray-200 rounded-xl p-4 relative transition-all hover:shadow-md hover:border-gray-300">
                  <div class="flex items-center justify-between">
                    <div class="flex items-center gap-3">
                      <div class="w-10 h-10 rounded-full bg-gray-100 text-gray-500 flex items-center justify-center">
                        <i class="fa-solid fa-users"></i>
                      </div>
                      <div>
                        <div class="font-medium text-gray-800" x-text="group.title"></div>
                        <div class="text-xs text-gray-400" x-text="group.id"></div>
                      </div>
                    </div>
                    <button type="button"
                      class="px-3 py-2 text-sm font-medium rounded-lg transition-all disabled:opacity-50 disabled:cursor-not-allowed"
                      :class="isGroupLimitReached ? 'bg-gray-100 text-gray-400' : 'bg-emerald-100 text-emerald-600 hover:bg-emerald-200'"
                      @click="activateGroup(group.id)"
                      :disabled="activatingGroupId === group.id || isGroupLimitReached">
                      <span x-show="activatingGroupId === group.id" class="spinner" style="width: 14px; height: 14px;"></span>
                      <span x-show="activatingGroupId !== group.id"><i class="fa-solid fa-plus mr-1"></i> <span class="hidden md:inline">Ativar</span></span>
                    </button>
                  </div>
                </div>
              </template>
            </div>
          </div>
        </template>

        <!-- Empty State - No Groups at All -->
        <template x-if="availableGroups.length === 0 && activeGroups.length === 0 && !loadingGroups && !groupsError">
          <div class="text-center p-8 bg-gray-100 rounded-xl">
            <i class="fa-solid fa-users-slash text-gray-400 text-3xl mb-3"></i>
            <p class="text-gray-600 font-medium mb-2">Nenhum grupo encontrado</p>
            <p class="text-gray-500 text-sm">Entre em grupos no Telegram para que eles apareçam aqui.</p>
          </div>
        </template>
      </div>
    </div>

    <!-- Subscription Section -->
    <div class="section mb-8 p-5 bg-gray-50 rounded-xl max-md:p-0 max-md:mb-6" x-show="activeSection === 'subscription'">
      <div class="section-header flex justify-between items-center mb-4 max-md:mx-3 max-md:py-3 max-md:border-b max-md:border-gray-200">
        <h2 class="text-gray-800 text-lg font-semibold flex items-center gap-1 max-md:text-base"><i class="fa-solid fa-credit-card"></i> Assinatura</h2>
      </div>
      <p class="section-description text-gray-500 text-sm mb-4">
        Gerencie sua assinatura e acesse a página de planos
      </p>

      <!-- Loading State -->
      <div x-show="loadingSubscription" class="text-center p-8">
        <div class="spinner mx-auto mb-4" style="width: 32px; height: 32px; border-width: 3px;"></div>
        <p class="text-gray-500">Carregando dados da assinatura...</p>
      </div>

      <!-- Subscription Content -->
      <div x-show="!loadingSubscription" class="flex flex-col gap-4">
        <!-- Current Subscription Status -->
        <div class="bg-white border-2 rounded-xl p-5"
          :class="{
            'border-emerald-200': subscriptionData?.status === 'active',
            'border-amber-200': subscriptionData?.status === 'trialing',
            'border-red-200': subscriptionData?.status === 'canceled' || subscriptionData?.status === 'expired',
            'border-gray-200': !subscriptionData
          }">

          <!-- No Subscription -->
          <template x-if="!subscriptionData">
            <div class="text-center py-4">
              <div class="w-16 h-16 mx-auto mb-4 rounded-full bg-gray-100 flex items-center justify-center">
                <i class="fa-solid fa-gift text-gray-400 text-2xl"></i>
              </div>
              <h3 class="text-lg font-semibold text-gray-800 mb-2">Sem assinatura ativa</h3>
              <p class="text-gray-500 text-sm mb-4">Comece um período de teste gratuito de 7 dias ou assine um plano.</p>
            </div>
          </template>

          <!-- Has Subscription -->
          <template x-if="subscriptionData">
            <div>
              <div class="flex items-start justify-between mb-4">
                <div>
                  <div class="flex items-center gap-2 mb-1">
                    <span class="text-lg font-bold text-gray-800" x-text="subscriptionData.plan?.displayName || 'Plano'"></span>
                    <span class="px-2 py-0.5 rounded-full text-xs font-semibold"
                      :class="{
                        'bg-emerald-200 text-emerald-800': subscriptionData.status === 'active',
                        'bg-amber-200 text-amber-800': subscriptionData.status === 'trialing',
                        'bg-red-200 text-red-800': subscriptionData.status === 'canceled' || subscriptionData.status === 'expired',
                        'bg-orange-200 text-orange-800': subscriptionData.status === 'past_due'
                      }"
                      x-text="getSubscriptionStatusLabel(subscriptionData.status)">
                    </span>
                  </div>
                  <p class="text-gray-600 text-sm" x-text="subscriptionData.plan?.priceInCents === 0 ? 'Gratuito' : `R$ ${(subscriptionData.plan?.priceInCents / 100).toFixed(2)}/mês`"></p>
                </div>
                <div class="w-12 h-12 rounded-full flex items-center justify-center"
                  :class="{
                    'bg-emerald-100 text-emerald-600': subscriptionData.status === 'active',
                    'bg-amber-100 text-amber-600': subscriptionData.status === 'trialing',
                    'bg-red-100 text-red-600': subscriptionData.status === 'canceled' || subscriptionData.status === 'expired',
                    'bg-orange-100 text-orange-600': subscriptionData.status === 'past_due'
                  }">
                  <i class="fa-solid text-xl"
                    :class="{
                      'fa-check': subscriptionData.status === 'active',
                      'fa-clock': subscriptionData.status === 'trialing',
                      'fa-times': subscriptionData.status === 'canceled' || subscriptionData.status === 'expired',
                      'fa-exclamation': subscriptionData.status === 'past_due'
                    }"></i>
                </div>
              </div>

              <!-- Usage Stats -->
              <div class="grid grid-cols-2 gap-4">
                <div class="bg-gray-50 rounded-xl p-3">
                  <p class="text-xs text-gray-500 mb-1">Grupos Ativos</p>
                  <p class="text-lg font-bold text-gray-800">
                    <span x-text="subscriptionData.activeGroupsCount || 0"></span>
                    <template x-if="subscriptionData.totalGroupLimit !== null">
                      <span>
                        <span class="text-gray-400 font-normal">/</span>
                        <span x-text="subscriptionData.totalGroupLimit"></span>
                      </span>
                    </template>
                    <template x-if="subscriptionData.totalGroupLimit === null">
                      <span class="text-gray-400 font-normal text-sm"> (ilimitados)</span>
                    </template>
                  </p>
                </div>
                <div class="bg-gray-50 rounded-xl p-3">
                  <p class="text-xs text-gray-500 mb-1" x-text="getSubscriptionDateLabel(subscriptionData.status)"></p>
                  <p class="text-lg font-bold text-gray-800" x-text="getSubscriptionDateValue(subscriptionData)"></p>
                </div>
              </div>

              <!-- Trial Warning -->
              <template x-if="subscriptionData.status === 'trialing' && subscriptionData.daysRemaining <= 3">
                <div class="mt-4 bg-amber-100 border border-amber-300 rounded-lg p-3 flex items-center gap-2">
                  <i class="fa-solid fa-exclamation-triangle text-amber-600"></i>
                  <p class="text-sm text-amber-800">
                    Seu periodo de teste expira em <strong x-text="subscriptionData.daysRemaining"></strong> dias.
                  </p>
                </div>
              </template>

              <!-- Canceled Info -->
              <template x-if="subscriptionData.status === 'canceled'">
                <div class="mt-4 bg-red-50 border border-red-200 rounded-lg p-3 flex items-center gap-2">
                  <i class="fa-solid fa-info-circle text-red-600"></i>
                  <p class="text-sm text-red-700">
                    Assinatura cancelada. Acesso disponivel ate <strong x-text="formatSubscriptionDate(subscriptionData.currentPeriodEnd)"></strong>.
                  </p>
                </div>
              </template>

              <!-- Past Due Info -->
              <template x-if="subscriptionData.status === 'past_due'">
                <div class="mt-4 bg-orange-50 border border-orange-200 rounded-lg p-3 flex items-center gap-2">
                  <i class="fa-solid fa-exclamation-triangle text-orange-600"></i>
                  <p class="text-sm text-orange-700">
                    Pagamento pendente. Atualize sua forma de pagamento para evitar a perda de acesso.
                  </p>
                </div>
              </template>
            </div>
          </template>
        </div>

        <!-- Actions -->
        <div class="flex flex-col gap-3">
          <!-- Manage Subscription Link -->
          <a href="/subscription"
            class="w-full px-6 py-4 bg-gradient-to-r from-primary to-secondary text-white font-semibold rounded-xl transition-all hover:shadow-lg hover:-translate-y-0.5 text-center no-underline flex items-center justify-center gap-2">
            <i class="fa-solid fa-external-link-alt"></i>
            Gerenciar Assinatura
          </a>
        </div>
      </div>
    </div>

    <!-- Bottom Sheet Overlay -->
    <div class="fixed inset-0 bg-black/50 z-[1000] transition-opacity duration-300 md:hidden"
      :class="bottomSheetOpen ? 'opacity-100' : 'opacity-0 pointer-events-none'"
      @click="closeBottomSheet()"></div>

    <!-- Bottom Sheet -->
    <div class="fixed bottom-0 left-0 right-0 bg-white rounded-t-[20px] max-h-[70vh] z-[1001] flex flex-col transition-transform duration-300 ease-out md:hidden"
      :class="bottomSheetOpen ? 'translate-y-0' : 'translate-y-full'">
      <div class="bottom-sheet-header p-5 border-b border-gray-200 flex items-center justify-between">
        <h3 class="text-lg m-0 text-gray-800">Selecionar Programa</h3>
        <button class="bottom-sheet-close w-9 h-9 border-none bg-gray-100 rounded-full text-xl text-gray-500 cursor-pointer flex items-center justify-center shrink-0 active:bg-gray-200" @click="closeBottomSheet()"><i class="fa-solid fa-xmark"></i></button>
      </div>
      <div class="p-5">
        <input type="search" class="bottom-sheet-search w-full p-3 border border-gray-200 rounded-xl text-base outline-none focus:border-primary" placeholder="Buscar programa..." x-model="programSearch">
      </div>
      <div class="bottom-sheet-content overflow-y-auto mx-2.5 px-2.5 flex-1">
        <template x-for="p in filteredPrograms" :key="p.id">
          <div class="flex items-center p-4 rounded-xl cursor-pointer transition-colors mb-2" 
            :class="selectedProgramId === p.id ? 'bg-linear-135 from-primary/10 to-secondary/10 border-2 border-primary' : 'hover:bg-gray-50 active:bg-gray-50'"
            @click="selectProgramFromSheet(p.id)">
            <div>
              <div class="program-list-item-name font-medium text-base text-gray-800" x-text="p.name"></div>
              <div class="program-list-item-stats text-sm text-gray-500 mt-1"
                x-text="`${getPriceCount(p.id)} preços • ${getMilesDisplay(p.id)} milhas`">
              </div>
            </div>
          </div>
        </template>
      </div>
    </div>

    <!-- Toast Notification -->
    <div class="fixed bottom-[100px] left-1/2 -translate-x-1/2 px-6 py-3 rounded-3xl text-sm z-[1000] text-white transition-all duration-300"
      :class="{
        'translate-y-[100px] opacity-0': !toast.visible,
        'translate-y-0 opacity-100': toast.visible,
        'bg-gray-800': !toast.type || (toast.type !== 'success' && toast.type !== 'error'),
        'bg-emerald-500': toast.type === 'success',
        'bg-red-500': toast.type === 'error'
      }"
      x-text="toast.message">
    </div>
  </div>
  <script>
    function dashboard() {
      return {
        // ============================================================================
        // State
        // ============================================================================
        programs: [],
        userData: { priceEntries: [], maxPrices: [], availableMiles: [] },
        selectedProgramId: null,
        hasUnsavedChanges: false,
        showOverview: false,
        loading: true,
        saving: false,
        errorMessage: null,
        carouselIndex: {},

        // Toast state
        toast: { visible: false, message: '', type: 'success' },

        // Bottom sheet state
        bottomSheetOpen: false,
        programSearch: '',

        // Swipe state
        touchStartX: 0,
        touchStartY: 0,

        // Section tabs state
        activeSection: 'prices', // 'prices' | 'limits' | 'counterOffer' | 'groups' | 'subscription'

        // Price type tab state (for mobile normal/liminar tabs)
        priceTypeTab: 'normal', // 'normal' | 'liminar'

        // Individual save state
        savingEntryIndex: null,

        // Program save state (for saving all prices of a program)
        savingProgramId: null,

        // Individual delete state
        deletingEntryIndex: null,

        // Editing quantity state (keeps edited entry in place while typing)
        editingEntry: null,        // Reference to the entry being edited
        editingEntryIndex: null,   // Visual position to keep the entry at (-1 = end)

        // Logout state
        loggingOut: false,

        // Counter offer state
        counterOfferSettings: {
          isEnabled: false,
          priceThreshold: 0.5,
          messageTemplateId: 1,
          callToActionTemplateId: 1,
        },
        counterOfferTemplates: [],
        callToActionTemplates: [],
        savingCounterOffer: false,
        counterOfferChanged: false,
        proposalSubTab: 'counterOffer', // 'counterOffer' | 'callToAction'

        // Groups state
        availableGroups: [],
        groupLimit: null,
        loadingGroups: false,
        loadingAvailableGroups: false,
        groupsError: false,
        groupsErrorMessage: '',
        groupsFetched: false,
        activatingGroupId: null,
        deactivatingGroupId: null,

        // Bot status state (preference)
        botStatus: { isEnabled: false },
        savingBotStatus: false,

        // Worker status state (live from server)
        workerStatus: { workerRunning: false, authState: null, lastAuthError: null },
        workerStatusLoaded: false,
        workerPollingInterval: null,
        workerStartingLocal: false, // frontend-local "starting" flag
        loginTriggered: false, // prevents duplicate login calls per start cycle
        startingPhraseIndex: 0,
        startingPhrases: [
          'Iniciando o servico...',
          'Preparando a conexao...',
          'Carregando componentes...',
          'Isso pode levar ate um minuto...',
          'Configurando o ambiente...',
          'Aguarde um momento...',
          'Inicializando o worker...',
          'Verificando dependencias...',
          'Conectando aos servidores...',
          'Preparando tudo pra voce...',
          'So mais um instante...',
          'Carregando configuracoes...',
          'Estabelecendo conexao segura...',
          'Quase pronto...',
          'Ainda trabalhando nisso...',
          'Organizando os dados...',
          'Validando credenciais...',
          'Sincronizando informacoes...',
          'Aguarde so mais um pouco...',
          'Estamos progredindo...',
          'Montando o ambiente...',
          'Alocando recursos...',
          'Processando a inicializacao...',
          'Falta pouco agora...',
          'Realizando verificacoes...',
          'Preparando a autenticacao...',
          'Estamos quase la...',
          'Conectando ao Telegram...',
          'Finalizando configuracao...',
          'Ja ja fica pronto...',
          'Ultimos ajustes...',
          'Iniciando comunicacao...',
          'Tudo certo por aqui, aguarde...',
          'Estabelecendo canal seguro...',
          'Carregando modulos...',
          'Otimizando a conexao...',
          'Ativando servicos...',
          'Finalizando preparativos...',
          'Quase tudo pronto...',
          'So mais alguns segundos...',
        ],
        authCode: '',
        authPassword: '',
        submittingAuth: false,
        reconnecting: false,

        // Subscription state
        subscriptionData: null,
        subscriptionPageUrl: null,
        loadingSubscription: false,
        subscriptionFetched: false,

        // ============================================================================
        // Computed Properties (as getters)
        // ============================================================================
        get normalPrograms() {
          return this.programs.filter(p => !p.isLiminar);
        },

        get selectedProgram() {
          return this.programs.find(p => p.id === this.selectedProgramId);
        },

        get filteredPrograms() {
          const q = this.programSearch.toLowerCase();
          return q ? this.normalPrograms.filter(p => p.name.toLowerCase().includes(q)) : this.normalPrograms;
        },

        get programsToShow() {
          const program = this.selectedProgram;
          if (!program) return [];
          const liminar = this.programs.find(p => p.liminarOfId === program.id);
          return liminar ? [program, liminar] : [program];
        },

        // Returns only the program for the selected price type tab (mobile)
        get currentPriceProgram() {
          const program = this.selectedProgram;
          if (!program) return [];

          const liminar = this.programs.find(p => p.liminarOfId === program.id);

          // Se não tem liminar, retorna só o programa normal
          if (!liminar) return [program];

          // Retorna baseado na aba selecionada
          return this.priceTypeTab === 'liminar' ? [liminar] : [program];
        },

        get currentProgramIndex() {
          return this.normalPrograms.findIndex(p => p.id === this.selectedProgramId);
        },

        get activeGroups() {
          return this.availableGroups.filter(g => g.isActive);
        },

        get inactiveGroups() {
          return this.availableGroups.filter(g => !g.isActive);
        },

        get isGroupLimitReached() {
          if (this.groupLimit === null) return false;
          return this.groupLimit > 0 && this.activeGroups.length >= this.groupLimit;
        },

        // ============================================================================
        // Initialization
        // ============================================================================
        async init() {
          try {
            await Promise.all([
              this.fetchPrograms(),
              this.fetchUserData(),
              this.fetchCounterOfferSettings(),
              this.fetchCounterOfferTemplates(),
              this.fetchCallToActionTemplates(),
              this.fetchBotStatus(),
            ]);

            if (this.normalPrograms.length > 0) {
              this.selectedProgramId = this.normalPrograms[0].id;
            }

            // Start polling if bot is enabled
            if (this.botStatus.isEnabled) {
              this.startWorkerPolling();
            }

            this.loading = false;
          } catch (error) {
            console.error('Initialization error:', error);
            this.errorMessage = error.message;
          }
        },

        // ============================================================================
        // Auth helpers
        // ============================================================================
        async authFetch(url, options) {
          const res = await fetch(url, options);
          if (res.status === 401) {
            window.location.href = '/login';
            throw new Error('Sessão expirada');
          }
          return res;
        },

        async logout() {
          this.loggingOut = true;
          try {
            await fetch('/login/logout', { method: 'POST' });
          } catch (e) {
            // ignore
          }
          window.location.href = '/login';
        },

        // ============================================================================
        // API Methods
        // ============================================================================
        async fetchPrograms() {
          const res = await this.authFetch('/dashboard/programs');
          const data = await res.json();
          if (data.success) {
            this.programs = data.data;
          } else {
            throw new Error(data.error || 'Failed to fetch programs');
          }
        },

        async fetchUserData() {
          const res = await this.authFetch('/dashboard/data');
          const data = await res.json();
          if (data.success) {
            this.userData = data.data;
          } else {
            throw new Error(data.error || 'Failed to fetch user data');
          }
        },

        async fetchCounterOfferSettings() {
          const res = await this.authFetch('/dashboard/counter-offer');
          const data = await res.json();
          if (data.success) {
            this.counterOfferSettings = data.data;
          } else {
            console.warn('Failed to fetch counter offer settings:', data.error);
            // Use defaults if fetch fails
          }
        },

        async fetchCounterOfferTemplates() {
          const res = await this.authFetch('/dashboard/counter-offer/templates');
          const data = await res.json();
          if (data.success) {
            this.counterOfferTemplates = data.data.templates;
          } else {
            console.warn('Failed to fetch counter offer templates:', data.error);
          }
        },

        async fetchCallToActionTemplates() {
          const res = await this.authFetch('/dashboard/call-to-action/templates');
          const data = await res.json();
          if (data.success) {
            this.callToActionTemplates = data.data.templates;
          } else {
            console.warn('Failed to fetch call to action templates:', data.error);
          }
        },

        async fetchBotStatus() {
          const res = await this.authFetch('/dashboard/bot-status');
          const data = await res.json();
          if (data.success) {
            this.botStatus = data.data;
          } else {
            console.warn('Failed to fetch bot status:', data.error);
          }
        },

        async handleToggle() {
          const enabling = this.botStatus.isEnabled;
          this.savingBotStatus = true;

          // Set starting state immediately so UI shows 'starting' instead of 'error'
          // while the bot-status request is in flight
          if (enabling) {
            this.workerStartingLocal = true;
            this.loginTriggered = false;
          }

          try {
            // 1. Save preference
            const res = await this.authFetch('/dashboard/bot-status', {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ isEnabled: enabling }),
            });
            const data = await res.json();
            if (!data.success) {
              this.botStatus.isEnabled = !enabling;
              this.workerStartingLocal = false;
              this.showToast('Erro ao salvar status do bot', 'error');
              return;
            }

            if (enabling) {
              // 2. Start worker (fire-and-forget — polling detects when container is healthy)
              this.showToast('Bot ativado!', 'success');
              this.startWorkerPolling();
              this._setStartingTimeout();
              this.authFetch('/dashboard/worker/start', { method: 'POST' }).catch(err => {
                console.error('Error triggering worker start:', err);
              });
            } else {
              // Disable: server already stopped the worker via PUT /bot-status
              this.stopWorkerPolling();
              this._clearStartingTimeout();
              this.workerStartingLocal = false;
              this.loginTriggered = false;
              this.workerStatus = { workerRunning: false, authState: null, lastAuthError: null };
              this.showToast('Bot desativado!', 'success');
            }
          } catch (error) {
            console.error('Error toggling bot:', error);
            this.botStatus.isEnabled = !enabling;
            this.workerStartingLocal = false;
            this.showToast('Erro ao salvar status do bot', 'error');
          } finally {
            this.savingBotStatus = false;
          }
        },

        // ============================================================================
        // Worker Status Management
        // ============================================================================

        /**
         * Connection status — derived from two independent dimensions:
         * 1. Bot preference (on/off)
         * 2. Worker + auth state
         * Returns: null | 'starting' | 'connecting' | 'needsCode' | 'needsPassword' | 'ready' | 'error'
         */
        getConnectionStatus() {
          if (!this.botStatus.isEnabled) return null;
          if (this.workerStartingLocal) return 'starting';
          if (!this.workerStatusLoaded) return 'starting';
          if (!this.workerStatus.workerRunning) return 'error';
          switch (this.workerStatus.authState) {
            case 'waitingCode':     return 'needsCode';
            case 'waitingPassword': return 'needsPassword';
            case 'ready':           return 'ready';
            default:                return 'connecting'; // idle or null
          }
        },

        async pollWorkerStatus() {
          try {
            const res = await this.authFetch('/dashboard/worker/status');
            const data = await res.json();
            if (!data.success) return;

            const prevAuthState = this.workerStatus.authState;
            const prevAuthError = this.workerStatus.lastAuthError;
            this.workerStatus = data.data;
            this.workerStatusLoaded = true;

            // Clear workerStartingLocal once worker is confirmed running
            if (this.workerStatus.workerRunning) {
              this._clearStartingTimeout();
              this.workerStartingLocal = false;
            }

            // Auto-trigger login when worker is running but not yet authorized
            if (this.workerStatus.workerRunning && !this.loginTriggered
                && this.workerStatus.authState !== 'ready'
                && this.workerStatus.authState !== 'waitingCode'
                && this.workerStatus.authState !== 'waitingPassword') {
              this.loginTriggered = true;
              try {
                await this.authFetch('/dashboard/worker/login', { method: 'POST' });
              } catch (err) {
                console.error('Auto-login failed:', err);
              }
            }

            // Reset loginTriggered when auth session completes (ready) so future re-auth can trigger
            if (this.workerStatus.authState === 'ready') {
              this.loginTriggered = false;
            }

            // Detect newly appeared errors
            const isNewError = this.workerStatus.lastAuthError && this.workerStatus.lastAuthError !== prevAuthError;

            // Clear form loading and notify user on auth errors
            if (this.submittingAuth) {
              if (this.workerStatus.lastAuthError) {
                this.submittingAuth = false;
                this.showAuthErrorToast(this.workerStatus.lastAuthError);
              } else if (this.workerStatus.authState !== prevAuthState) {
                this.submittingAuth = false;
              }
            }

            // Show auth errors when newly detected (not during submission)
            if (!this.submittingAuth && isNewError) {
              this.showAuthErrorToast(this.workerStatus.lastAuthError);
            }

            // Advance starting phrase while starting
            const connStatus = this.getConnectionStatus();
            if (connStatus === 'starting') {
              this.startingPhraseIndex = (this.startingPhraseIndex + 1) % this.startingPhrases.length;
            } else {
              this.startingPhraseIndex = 0;
            }

            // Adjust polling rate: active (3s) vs background (30s) vs off
            this.adjustPollingRate();
          } catch (error) {
            console.error('Error polling worker status:', error);
          }
        },

        adjustPollingRate() {
          const connStatus = this.getConnectionStatus();
          if (connStatus === null) {
            // Bot off — stop polling
            this.stopWorkerPolling();
            return;
          }
          if (connStatus === 'ready') {
            // Background poll at 30s
            if (this._pollingRate !== 'background') {
              this._pollingRate = 'background';
              this.stopWorkerPolling();
              this.workerPollingInterval = setInterval(() => this.pollWorkerStatus(), 30000);
            }
          } else {
            // Active poll at 3s
            if (this._pollingRate !== 'active') {
              this._pollingRate = 'active';
              this.stopWorkerPolling();
              this.workerPollingInterval = setInterval(() => this.pollWorkerStatus(), 3000);
            }
          }
        },

        startWorkerPolling() {
          this.stopWorkerPolling();
          this._pollingRate = 'active';
          // Poll immediately
          this.pollWorkerStatus();
          // Then every 3 seconds (adjustPollingRate will switch to background when ready)
          this.workerPollingInterval = setInterval(() => this.pollWorkerStatus(), 3000);
        },

        stopWorkerPolling() {
          if (this.workerPollingInterval) {
            clearInterval(this.workerPollingInterval);
            this.workerPollingInterval = null;
          }
          this._pollingRate = null;
        },

        async reconnectWorker() {
          this.reconnecting = true;
          this.workerStartingLocal = true;
          this.loginTriggered = false;
          this.startWorkerPolling();
          this._setStartingTimeout();
          // Fire-and-forget
          this.authFetch('/dashboard/worker/start', { method: 'POST' }).catch(err => {
            console.error('Error triggering worker start:', err);
          });
          this.showToast('Reconectando...', 'success');
          this.reconnecting = false;
        },

        _setStartingTimeout() {
          clearTimeout(this._startingTimeout);
          this._startingTimeout = setTimeout(() => {
            if (this.workerStartingLocal) {
              this.workerStartingLocal = false;
            }
          }, 120000);
        },

        _clearStartingTimeout() {
          clearTimeout(this._startingTimeout);
          this._startingTimeout = null;
        },

        getWorkerIndicatorClass() {
          const connStatus = this.getConnectionStatus();
          const map = {
            null:           'bg-gray-100 text-gray-400',
            starting:       'bg-blue-100 text-blue-600',
            connecting:     'bg-blue-100 text-blue-600',
            needsCode:      'bg-amber-100 text-amber-600',
            needsPassword:  'bg-amber-100 text-amber-600',
            ready:          'bg-emerald-100 text-emerald-600',
            error:          'bg-red-100 text-red-600',
          };
          return map[connStatus] || 'bg-gray-100 text-gray-400';
        },

        getWorkerIndicatorIcon() {
          const connStatus = this.getConnectionStatus();
          const map = {
            null:           'fa-pause',
            starting:       'fa-spinner fa-spin',
            connecting:     'fa-spinner fa-spin',
            needsCode:      'fa-shield-halved',
            needsPassword:  'fa-lock',
            ready:          'fa-play',
            error:          'fa-plug-circle-xmark',
          };
          return map[connStatus] || 'fa-pause';
        },

        getWorkerStatusText() {
          const connStatus = this.getConnectionStatus();
          if (connStatus === 'starting') return this.startingPhrases[this.startingPhraseIndex];
          const map = {
            null:           'Bot desativado — ative para responder nos grupos automaticamente',
            connecting:     'Estabelecendo conexao com o Telegram...',
            needsCode:      'Quase la! Informe o codigo enviado pelo Telegram',
            needsPassword:  'Mais um passo — digite sua senha do Telegram',
            ready:          'Tudo certo! Conectado e respondendo nos grupos',
            error:          'Conexao perdida — clique em Reconectar para voltar',
          };
          return map[connStatus] || 'Verificando status da conexao...';
        },

        showAuthErrorToast(errorCode) {
          if (errorCode.startsWith('FLOOD_WAIT:')) {
            const seconds = parseInt(errorCode.split(':')[1], 10);
            const minutes = Math.ceil(seconds / 60);
            this.showToast(`Muitas tentativas seguidas. Por seguranca, aguarde ~${minutes} minuto(s) antes de tentar novamente.`, 'error');
          } else if (errorCode === 'PASSWORD_INVALID') {
            this.showToast('Senha incorreta. Verifique e tente novamente.', 'error');
          } else if (errorCode === 'CODE_INVALID') {
            this.showToast('Codigo incorreto. Confira o codigo recebido no Telegram e tente novamente.', 'error');
          } else if (errorCode === 'CODE_EXPIRED') {
            this.showToast('Codigo expirado. Desative e ative o bot novamente para receber um novo codigo.', 'error');
          } else if (errorCode === 'WORKER_STARTUP_FAILED') {
            this.showToast('Nao foi possivel iniciar a conexao. Tente reconectar em alguns instantes.', 'error');
          } else if (errorCode === 'WORKER_STARTUP_ERROR') {
            this.showToast('Ocorreu um erro ao conectar. Tente reconectar em alguns instantes.', 'error');
          } else {
            this.showToast('Algo deu errado. Tente novamente em alguns instantes.', 'error');
          }
        },

        async submitAuthCode() {
          if (this.submittingAuth || this.authCode.length < 4) return;
          this.submittingAuth = true;
          try {
            const res = await this.authFetch('/dashboard/worker/auth-code', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ code: this.authCode }),
            });
            const data = await res.json();
            if (data.success) {
              this.authCode = '';
              this.showToast('Codigo enviado! Verificando...', 'success');
              // Keep submittingAuth=true so form stays in loading state
              // Poll will update authState and clear it
              this.startWorkerPolling();
            } else {
              this.showToast('Erro ao enviar código: ' + (data.error || 'Erro desconhecido'), 'error');
              this.submittingAuth = false;
            }
          } catch (error) {
            console.error('Error submitting auth code:', error);
            this.showToast('Erro ao enviar código', 'error');
            this.submittingAuth = false;
          }
        },

        async submitPassword() {
          if (this.submittingAuth || this.authPassword.length === 0) return;
          this.submittingAuth = true;
          try {
            const res = await this.authFetch('/dashboard/worker/password', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ password: this.authPassword }),
            });
            const data = await res.json();
            if (data.success) {
              this.authPassword = '';
              this.showToast('Senha enviada! Autenticando...', 'success');
              // Keep submittingAuth=true so form stays in loading state
              // Poll will update authState and clear it
              this.startWorkerPolling();
            } else {
              this.showToast('Erro ao enviar senha: ' + (data.error || 'Erro desconhecido'), 'error');
              this.submittingAuth = false;
            }
          } catch (error) {
            console.error('Error submitting password:', error);
            this.showToast('Erro ao enviar senha', 'error');
            this.submittingAuth = false;
          }
        },

        async fetchGroupsIfNeeded() {
          if (!this.groupsFetched) {
            await this.fetchAvailableGroups();
          }
        },

        async fetchSubscriptionIfNeeded() {
          if (!this.subscriptionFetched) {
            await this.fetchSubscription();
          }
        },

        async fetchSubscription() {
          this.loadingSubscription = true;
          try {
            const res = await this.authFetch('/dashboard/subscription');
            const data = await res.json();
            if (data.success) {
              this.subscriptionData = data.data.subscription;
              this.normalizeSubscriptionStatus();
              this.subscriptionPageUrl = data.data.subscriptionPageUrl;
              this.subscriptionFetched = true;
            } else {
              console.warn('Failed to fetch subscription:', data.error);
            }
          } catch (error) {
            console.error('Error fetching subscription:', error);
          } finally {
            this.loadingSubscription = false;
          }
        },

        normalizeSubscriptionStatus() {
          if (!this.subscriptionData) return;
          if (this.subscriptionData.status === 'expired' || this.subscriptionData.status === 'canceled') return;
          if (this.subscriptionData.currentPeriodEnd && new Date(this.subscriptionData.currentPeriodEnd) < new Date()) {
            this.subscriptionData.status = 'expired';
          }
        },

        getSubscriptionStatusLabel(status) {
          const labels = {
            'active': 'Ativo',
            'trialing': 'Periodo de Teste',
            'past_due': 'Pagamento Pendente',
            'canceled': 'Cancelado',
            'expired': 'Expirado',
          };
          return labels[status] || status;
        },

        getSubscriptionDateLabel(status) {
          if (status === 'trialing') return 'Dias Restantes';
          if (status === 'canceled' || status === 'expired') return 'Acesso até';
          return 'Proxima Cobranca';
        },

        getSubscriptionDateValue(sub) {
          if (sub.status === 'trialing') return (sub.daysRemaining || 0) + ' dias';
          if (sub.status === 'canceled' || sub.status === 'expired') return this.formatSubscriptionDate(sub.currentPeriodEnd);
          return this.formatSubscriptionDate(sub.nextBillingDate);
        },

        formatSubscriptionDate(dateStr) {
          if (!dateStr) return '-';
          const date = new Date(dateStr);
          return date.toLocaleDateString('pt-BR', {
            day: '2-digit',
            month: '2-digit',
            year: 'numeric',
          });
        },

        async fetchAvailableGroups() {
          this.loadingGroups = true;
          this.loadingAvailableGroups = true;
          this.groupsError = false;
          this.groupsErrorMessage = '';

          try {
            const res = await this.authFetch('/dashboard/available-groups');
            const data = await res.json();
            
            if (data.success) {
              this.availableGroups = data.data.groups;
              this.groupLimit = data.data.groupLimit;
              this.groupsFetched = true;
            } else {
              this.groupsError = true;
              if (data.error === 'user_not_logged_in') {
                this.groupsErrorMessage = 'Você precisa fazer login no bot antes de gerenciar grupos. Use o comando /login no Telegram.';
              } else if (data.error === 'worker_unavailable') {
                this.groupsErrorMessage = 'O serviço de conexão com o Telegram não está disponível. Tente novamente mais tarde.';
              } else {
                this.groupsErrorMessage = data.error || 'Erro desconhecido ao carregar grupos';
              }
            }
          } catch (error) {
            console.error('Error fetching available groups:', error);
            this.groupsError = true;
            this.groupsErrorMessage = 'Erro de conexão. Verifique sua internet e tente novamente.';
          } finally {
            this.loadingGroups = false;
            this.loadingAvailableGroups = false;
          }
        },

        async activateGroup(groupId) {
          this.activatingGroupId = groupId;
          
          try {
            const res = await this.authFetch(`/dashboard/groups/${groupId}`, {
              method: 'POST',
            });
            const data = await res.json();
            
            if (data.success) {
              // Update local state
              const group = this.availableGroups.find(g => g.id === groupId);
              if (group) {
                group.isActive = true;
              }
              this.showToast('Grupo ativado com sucesso!', 'success');
            } else {
              if (data.error === 'group_limit_reached') {
                this.groupLimit = data.data?.limit ?? this.groupLimit;
                this.showToast(`Limite de grupos atingido (${data.data?.currentCount ?? this.activeGroups.length}/${data.data?.limit ?? this.groupLimit}). Faça upgrade do plano para ativar mais grupos.`, 'error');
              } else if (data.error === 'group_not_found') {
                this.showToast('Grupo não encontrado', 'error');
              } else if (data.error === 'not_a_group') {
                this.showToast('Este chat não é um grupo', 'error');
              } else {
                this.showToast('Erro ao ativar grupo: ' + (data.error || 'Erro desconhecido'), 'error');
              }
            }
          } catch (error) {
            console.error('Error activating group:', error);
            this.showToast('Erro ao ativar grupo', 'error');
          } finally {
            this.activatingGroupId = null;
          }
        },

        async deactivateGroup(groupId) {
          this.deactivatingGroupId = groupId;
          
          try {
            const res = await this.authFetch(`/dashboard/groups/${groupId}`, {
              method: 'DELETE',
            });
            const data = await res.json();
            
            if (data.success) {
              // Update local state
              const group = this.availableGroups.find(g => g.id === groupId);
              if (group) {
                group.isActive = false;
              }
              this.showToast('Grupo desativado com sucesso!', 'success');
            } else {
              this.showToast('Erro ao desativar grupo: ' + (data.error || 'Erro desconhecido'), 'error');
            }
          } catch (error) {
            console.error('Error deactivating group:', error);
            this.showToast('Erro ao desativar grupo', 'error');
          } finally {
            this.deactivatingGroupId = null;
          }
        },

        async saveCounterOfferSettingsApi(settings) {
          const res = await this.authFetch('/dashboard/counter-offer', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(settings),
          });
          const data = await res.json();
          if (!data.success) {
            throw new Error(data.error || 'Failed to save counter offer settings');
          }
          return data;
        },

        async savePricesApi(entries) {
          const res = await this.authFetch('/dashboard/prices', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ entries }),
          });
          const data = await res.json();
          if (!data.success) {
            throw new Error(data.error || 'Failed to save prices');
          }
          return data;
        },

        async saveSinglePriceApi(entry) {
          const res = await this.authFetch('/dashboard/price', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(entry),
          });
          const data = await res.json();
          if (!data.success) {
            throw new Error(data.error || 'Failed to save price');
          }
          return data;
        },

        async saveProgramPricesApi(programId, entries) {
          const res = await this.authFetch(`/dashboard/prices/${programId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ entries }),
          });
          const data = await res.json();
          if (!data.success) {
            throw new Error(data.error || 'Failed to save prices');
          }
          return data;
        },

        async saveMaxPricesApi(maxPrices) {
          const res = await this.authFetch('/dashboard/max-prices', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ maxPrices }),
          });
          const data = await res.json();
          if (!data.success) {
            throw new Error(data.error || 'Failed to save max prices');
          }
          return data;
        },

        async saveMilesApi(miles) {
          const res = await this.authFetch('/dashboard/miles', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ miles }),
          });
          const data = await res.json();
          if (!data.success) {
            throw new Error(data.error || 'Failed to save miles');
          }
          return data;
        },

        // ============================================================================
        // Save Actions
        // ============================================================================
        async saveAll() {
          if (!this.hasUnsavedChanges) {
            this.showToast('Nenhuma alteração para salvar', 'success');
            return;
          }

          this.saving = true;

          try {
            const priceEntries = this.collectPriceEntries();
            if (priceEntries.length > 0) {
              await this.savePricesApi(priceEntries);
            }

            const maxPricesData = this.collectMaxPrices();
            if (maxPricesData.length > 0) {
              await this.saveMaxPricesApi(maxPricesData);
            }

            const milesData = this.collectMiles();
            if (milesData.length > 0) {
              await this.saveMilesApi(milesData);
            }

            await this.fetchUserData();
            this.hasUnsavedChanges = false;
            this.showToast('Tudo salvo com sucesso!', 'success');
          } catch (error) {
            this.showToast('Erro ao salvar: ' + error.message, 'error');
          } finally {
            this.saving = false;
          }
        },

        async savePrices() {
          this.saving = true;
          try {
            const entries = this.collectPriceEntries();
            await this.savePricesApi(entries);
            await this.fetchUserData();
            this.showToast('Preços salvos com sucesso!', 'success');
            this.hasUnsavedChanges = false;
          } catch (error) {
            this.showToast('Erro ao salvar: ' + error.message, 'error');
          } finally {
            this.saving = false;
          }
        },

        async saveSinglePriceEntry(programId, index) {
          const entries = this.getPriceEntries(programId);
          const entry = entries[index];

          if (!this.isValidPriceEntry(entry)) {
            this.showToast('Preencha quantidade e preço', 'error');
            return;
          }

          this.savingEntryIndex = index;

          try {
            const payload = {
              programId: entry.programId,
              quantity: entry.quantity,
              price: entry.price,
            };
            // Include id if it exists (for updating existing entries)
            if (entry.id) {
              payload.id = entry.id;
            }
            await this.saveSinglePriceApi(payload);
            this.showToast('Preço salvo!', 'success');
          } catch (error) {
            this.showToast('Erro ao salvar: ' + error.message, 'error');
          } finally {
            this.savingEntryIndex = null;
            // Clear editing state to allow reordering after save
            this.editingEntry = null;
            this.editingEntryIndex = null;
          }
        },

        async saveProgramPrices(programId) {
          const entries = this.getPriceEntries(programId)
            .filter(e => this.isValidPriceEntry(e))
            .map(e => ({ quantity: e.quantity, price: e.price }));

          if (entries.length === 0) {
            this.showToast('Nenhum preço válido para salvar', 'error');
            return;
          }

          this.savingProgramId = programId;
          try {
            await this.saveProgramPricesApi(programId, entries);
            // Also save all max prices (includes ceiling price for this program)
            const maxPrices = this.collectMaxPrices();
            await this.saveMaxPricesApi(maxPrices);
            await this.fetchUserData();
            this.showToast('Preços salvos!', 'success');
          } catch (error) {
            this.showToast('Erro ao salvar: ' + error.message, 'error');
          } finally {
            this.savingProgramId = null;
          }
        },

        async saveLimits() {
          this.saving = true;
          try {
            const miles = this.collectMiles();
            await this.saveMilesApi(miles);
            const maxPrices = this.collectMaxPrices();
            await this.saveMaxPricesApi(maxPrices);
            await this.fetchUserData();
            this.showToast('Limites salvos!', 'success');
            this.hasUnsavedChanges = false;
          } catch (error) {
            this.showToast('Erro ao salvar: ' + error.message, 'error');
          } finally {
            this.saving = false;
          }
        },

        async saveCounterOfferSettings() {
          this.savingCounterOffer = true;
          try {
            await this.saveCounterOfferSettingsApi(this.counterOfferSettings);
            this.showToast('Configurações de proposta salvas!', 'success');
            this.counterOfferChanged = false;
          } catch (error) {
            this.showToast('Erro ao salvar: ' + error.message, 'error');
          } finally {
            this.savingCounterOffer = false;
          }
        },

        markCounterOfferChanged() {
          this.counterOfferChanged = true;
        },

        // ============================================================================
        // Data Collection
        // ============================================================================
        collectPriceEntries() {
          return this.userData.priceEntries
            .filter(e => e.quantity > 0 && e.price > 0)
            .map(e => ({ programId: e.programId, quantity: e.quantity, price: e.price }));
        },

        collectMaxPrices() {
          return this.userData.maxPrices
            .filter(mp => mp.maxPrice > 0 || mp.minQuantity > 0)
            .map(mp => ({ programId: mp.programId, maxPrice: mp.maxPrice, minQuantity: mp.minQuantity || 0 }));
        },

        collectMiles() {
          return this.userData.availableMiles
            .filter(m => m.availableMiles >= 0)
            .map(m => ({ programId: m.programId, availableMiles: m.availableMiles }));
        },

        // ============================================================================
        // Helper Methods
        // ============================================================================
        getPriceEntries(programId) {
          const entries = this.userData.priceEntries
            .filter(e => e.programId === programId);
          
          // Check if we're editing an entry in this program
          const isEditingInThisProgram = this.editingEntry && 
            entries.includes(this.editingEntry);
          
          if (!isEditingInThisProgram) {
            // Normal sorting when not editing
            return entries.sort((a, b) => a.quantity - b.quantity);
          }
          
          // Sort all entries except the one being edited
          const editingEntry = this.editingEntry;
          const targetIndex = this.editingEntryIndex;
          
          // Get entries without the editing one and sort them
          const otherEntries = entries.filter(e => e !== editingEntry);
          otherEntries.sort((a, b) => a.quantity - b.quantity);
          
          // Insert the editing entry at its target position
          if (targetIndex === -1 || targetIndex >= otherEntries.length) {
            // Put at the end
            otherEntries.push(editingEntry);
          } else {
            // Insert at the stored position
            otherEntries.splice(targetIndex, 0, editingEntry);
          }
          
          return otherEntries;
        },

        isValidPriceEntry(entry) {
          return entry.quantity > 0 && entry.price > 0;
        },

        hasValidPricesForProgram(programId) {
          const entries = this.getPriceEntries(programId);
          return entries.some(e => this.isValidPriceEntry(e));
        },

        getMaxPrice(programId) {
          return this.userData.maxPrices.find(mp => mp.programId === programId);
        },

        getMiles(programId) {
          return this.userData.availableMiles.find(am => am.programId === programId);
        },

        getPriceCount(programId) {
          return this.getPriceEntries(programId).length;
        },

        getMilesDisplay(programId) {
          const m = this.getMiles(programId);
          return m ? `${(m.availableMiles / 1000).toFixed(0)}k` : '0';
        },

        getMaxPriceDisplay(programId) {
          const mp = this.getMaxPrice(programId);
          return mp ? `R$ ${mp.maxPrice.toFixed(2)}` : null;
        },

        hasLiminar() {
          const program = this.selectedProgram;
          if (!program) return false;
          return this.programs.some(p => p.liminarOfId === program.id);
        },

        // Determines if a program should be shown in the price section (tabs logic)
        shouldShowPriceProgram(prog) {
          // If no liminar exists for current program, always show
          if (!this.hasLiminar()) return true;

          // Show based on selected tab
          return this.priceTypeTab === 'liminar' ? prog.isLiminar : !prog.isLiminar;
        },

        // ============================================================================
        // Program Selection
        // ============================================================================
        selectProgram(programId) {
          this.selectedProgramId = programId;
          // Reset price type tab to normal when changing programs
          this.priceTypeTab = 'normal';
          // Clear editing state to allow reordering
          this.editingEntry = null;
          this.editingEntryIndex = null;
          // Scroll active pill into view
          this.$nextTick(() => {
            const activePill = document.querySelector('.pill.active');
            if (activePill) {
              activePill.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
            }
          });
        },

        // ============================================================================
        // Price Entry Management
        // ============================================================================
        addPriceEntry(programId) {
          const newEntry = {
            programId,
            programName: this.programs.find(p => p.id === programId)?.name ?? '',
            quantity: 0,
            price: 0,
          };
          this.userData.priceEntries.push(newEntry);
          this.hasUnsavedChanges = true;

          // Keep the new entry at the end while editing
          this.editingEntry = newEntry;
          this.editingEntryIndex = -1; // -1 means "at the end"

          // Update carousel to show the new card
          const entries = this.getPriceEntries(programId);
          this.carouselIndex[programId] = entries.length - 1;
        },

        async removePriceEntry(programId, index) {
          const entries = this.getPriceEntries(programId);
          const entry = entries[index];
          const globalIndex = this.userData.priceEntries.indexOf(entry);

          if (globalIndex > -1) {
            // If entry has an id (persisted in DB), call DELETE API
            if (entry.id) {
              this.deletingEntryIndex = index;
              try {
                const res = await this.authFetch(`/dashboard/price/${entry.id}`, {
                  method: 'DELETE',
                });
                const data = await res.json();
                if (!data.success) {
                  this.showToast('Erro ao remover: ' + (data.error || 'Falha ao remover'), 'error');
                  return;
                }
              } catch (error) {
                this.showToast('Erro ao remover: ' + error.message, 'error');
                return;
              } finally {
                this.deletingEntryIndex = null;
              }
            }

            // Remove from local array
            this.userData.priceEntries.splice(globalIndex, 1);
            this.hasUnsavedChanges = true;

            // Adjust carousel index
            const currentIndex = this.carouselIndex[programId] || 0;
            if (currentIndex >= entries.length - 1) {
              this.carouselIndex[programId] = Math.max(0, entries.length - 2);
            }

            if (entry.id) {
              this.showToast('Preço removido!', 'success');
            }
          }
        },

        // ============================================================================
        // Max Price Management
        // ============================================================================
        ensureMaxPriceEntry(programId) {
          let entry = this.userData.maxPrices.find(mp => mp.programId === programId);
          if (!entry) {
            entry = {
              programId,
              programName: this.programs.find(p => p.id === programId)?.name ?? '',
              maxPrice: 0,
              minQuantity: 0,
            };
            this.userData.maxPrices.push(entry);
          }
          return entry;
        },

        updateMaxPrice(programId, value) {
          const entry = this.ensureMaxPriceEntry(programId);
          entry.maxPrice = this.parseNumber(value, true) || 0;
          this.hasUnsavedChanges = true;
        },

        getMinQuantity(programId) {
          const entry = this.userData.maxPrices.find(mp => mp.programId === programId);
          return entry?.minQuantity || '';
        },

        updateMinQuantity(programId, value) {
          const entry = this.ensureMaxPriceEntry(programId);
          entry.minQuantity = parseInt(value, 10) || 0;
          this.hasUnsavedChanges = true;
        },

        // ============================================================================
        // Miles Management
        // ============================================================================
        ensureMilesEntry(programId) {
          let entry = this.userData.availableMiles.find(am => am.programId === programId);
          if (!entry) {
            entry = {
              programId,
              programName: this.programs.find(p => p.id === programId)?.name ?? '',
              availableMiles: 0,
            };
            this.userData.availableMiles.push(entry);
          }
          return entry;
        },

        updateMiles(programId, value) {
          const entry = this.ensureMilesEntry(programId);
          entry.availableMiles = this.parseNumber(value, false) || 0;
          this.hasUnsavedChanges = true;
        },

        // ============================================================================
        // Carousel
        // ============================================================================
        getCarouselIndex(programId) {
          if (this.carouselIndex[programId] === undefined) {
            this.carouselIndex[programId] = 0;
          }
          const entries = this.getPriceEntries(programId);
          const maxIndex = Math.max(0, entries.length - 1);
          if (this.carouselIndex[programId] > maxIndex) {
            this.carouselIndex[programId] = maxIndex;
          }
          return this.carouselIndex[programId];
        },

        setCarouselIndex(programId, index) {
          this.carouselIndex[programId] = index;
        },

        nextCarousel(programId) {
          const entries = this.getPriceEntries(programId);
          const current = this.getCarouselIndex(programId);
          if (current < entries.length - 1) {
            this.carouselIndex[programId] = current + 1;
          }
        },

        prevCarousel(programId) {
          const current = this.getCarouselIndex(programId);
          if (current > 0) {
            this.carouselIndex[programId] = current - 1;
          }
        },

        // ============================================================================
        // Toast
        // ============================================================================
        showToast(message, type = 'success') {
          this.toast = { visible: true, message, type };
          setTimeout(() => {
            this.toast.visible = false;
          }, 3000);
        },

        // ============================================================================
        // Overview Mode
        // ============================================================================
        toggleOverview() {
          this.showOverview = !this.showOverview;
        },

        selectProgramFromOverview(programId) {
          this.selectProgram(programId);
          this.showOverview = false;
        },

        // ============================================================================
        // Bottom Sheet
        // ============================================================================
        openBottomSheet() {
          this.programSearch = '';
          this.bottomSheetOpen = true;
        },

        closeBottomSheet() {
          this.bottomSheetOpen = false;
        },

        selectProgramFromSheet(programId) {
          this.selectProgram(programId);
          this.closeBottomSheet();
        },

        // ============================================================================
        // Swipe Gestures
        // ============================================================================
        onTouchStart(e) {
          this.touchStartX = e.touches[0].clientX;
          this.touchStartY = e.touches[0].clientY;
        },

        onTouchEnd(e) {
          const diffX = this.touchStartX - e.changedTouches[0].clientX;
          const diffY = this.touchStartY - e.changedTouches[0].clientY;

          if (Math.abs(diffX) > 80 && Math.abs(diffX) > Math.abs(diffY) * 2) {
            this.navigateProgram(diffX > 0 ? 1 : -1);
          }
        },

        navigateProgram(direction) {
          const currentIndex = this.currentProgramIndex;
          if (currentIndex === -1) return;

          const newIndex = currentIndex + direction;

          if (newIndex >= 0 && newIndex < this.normalPrograms.length) {
            this.selectProgram(this.normalPrograms[newIndex].id);
          }
        },

        // ============================================================================
        // Utility
        // ============================================================================
        isMobile() {
          return window.innerWidth <= 768;
        },

        parseNumber(value, allowDecimal = true) {
          if (!value && value !== 0) return null;
          // Substitui vírgula por ponto e remove caracteres inválidos
          const normalized = String(value).replace(',', '.').replace(/[^\d.]/g, '');
          const parsed = allowDecimal ? parseFloat(normalized) : parseInt(normalized, 10);
          return Number.isNaN(parsed) ? null : parsed;
        },

        formatThousands(value) {
          if (!value || value === 0) return '';
          return Number(value).toLocaleString('pt-BR');
        },

        formatThousandsInput(event) {
          const raw = event.target.value.replace(/\D/g, '');
          if (raw === '') { event.target.value = ''; return; }
          event.target.value = Number(raw).toLocaleString('pt-BR');
        },

        formatInput(event, allowDecimal = true) {
          const input = event.target;
          // Permite apenas dígitos, ponto e vírgula
          const pattern = allowDecimal ? /[^\d.,]/g : /[^\d]/g;
          input.value = input.value.replace(pattern, '');
        },

        isValidNumber(value, min = 0, allowDecimal = true) {
          const parsed = this.parseNumber(value, allowDecimal);
          return parsed !== null && parsed >= min;
        },

        markAsChanged() {
          this.hasUnsavedChanges = true;
        },
      };
    }
  </script>
</body>

</html>
