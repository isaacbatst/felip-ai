<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Dashboard - Configurações de Milhas</title>
  <link rel="stylesheet" href="/public/dashboard.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  <script defer src="https://unpkg.com/alpinejs@3.13.3/dist/cdn.min.js"></script>
</head>

<body x-data="dashboard()" x-init="init()" x-cloak>
  <!-- Loading Overlay -->
  <div class="loading-overlay" :class="{ 'hidden': !loading && !errorMessage }">
    <div style="text-align: center;" x-show="loading && !errorMessage">
      <div class="spinner" style="width: 40px; height: 40px; border-width: 4px;"></div>
      <p style="margin-top: 16px; color: #666;">Carregando...</p>
    </div>
    <div style="text-align: center; padding: 40px;" x-show="errorMessage">
      <div style="margin-bottom: 16px;"><i class="fa-solid fa-triangle-exclamation icon-error"></i></div>
      <h2 style="color: #721c24; margin-bottom: 8px;">Link Inválido</h2>
      <p style="color: #666;" x-text="errorMessage"></p>
    </div>
  </div>

  <div class="container" x-show="!loading && !errorMessage">
    <div class="header">
      <h1>Dashboard</h1>
      <div class="header-timer" x-show="expiresAt" :class="{ 'warning': timerWarning, 'expired': timerExpired }">
        <span x-text="timerExpired ? 'Link expirado' : `Expira em: ${countdownDisplay}`"></span>
      </div>
    </div>
    <!-- Programs Tabs (Desktop) -->
    <div class="tabs">
      <template x-for="p in normalPrograms" :key="p.id">
        <button class="tab-btn" :class="{ 'active': selectedProgramId === p.id }" @click="selectProgram(p.id)"
          x-text="p.name">
        </button>
      </template>
    </div>

    <!-- Mobile Pills Navigation -->
    <div class="program-pills-container">
      <div class="program-pills">
        <template x-for="p in normalPrograms" :key="p.id">
          <button class="pill" :class="{ 'active': selectedProgramId === p.id }" @click="selectProgram(p.id)"
            x-text="p.name">
          </button>
        </template>
      </div>
      <button class="program-selector-btn" @click="openBottomSheet()"><i class="fa-solid fa-bars"></i></button>
    </div>

    <div class="mobile-controls">
      <!-- Program Indicator (Mobile) -->
      <div class="program-indicator">
        Programa: <strong x-text="selectedProgram?.name || '-'"></strong>
      </div>

      <!-- Overview Toggle (Mobile) -->
      <button class="overview-toggle" @click="toggleOverview()">
        <template x-if="showOverview">
          <span><i class="fa-solid fa-arrow-left"></i> Voltar para detalhes</span>
        </template>
        <template x-if="!showOverview">
          <span><i class="fa-solid fa-table-cells"></i> Ver todos os programas</span>
        </template>
      </button>
    </div>

    <!-- Overview Grid (Mobile) -->
    <div class="overview-grid" :style="{ display: showOverview ? 'grid' : 'none' }">
      <template x-for="p in normalPrograms" :key="p.id">
        <div class="overview-card" :class="{ 'active': selectedProgramId === p.id }"
          @click="selectProgramFromOverview(p.id)">
          <div class="overview-card-name" x-text="p.name"></div>
          <div class="overview-card-stats">
            <div class="overview-card-stat">Preços: <span x-text="getPriceCount(p.id)"></span></div>
            <div class="overview-card-stat">Milhas: <span x-text="getMilesDisplay(p.id)"></span></div>
            <template x-if="getMaxPriceDisplay(p.id)">
              <div class="overview-card-stat">Teto: <span x-text="getMaxPriceDisplay(p.id)"></span></div>
            </template>
          </div>
        </div>
      </template>
    </div>

    <!-- Content Container (with swipe support on mobile) -->
    <div id="mobileContent" x-show="!showOverview" @touchstart="onTouchStart($event)" @touchend="onTouchEnd($event)">

      <!-- Section Tabs -->
      <div class="section-tabs">
        <button class="section-tab" :class="{ 'active': activeSection === 'prices' }" @click="activeSection = 'prices'">
          <i class="fa-solid fa-chart-simple"></i> Preços
        </button>
        <button class="section-tab" :class="{ 'active': activeSection === 'maxPrices' }"
          @click="activeSection = 'maxPrices'">
          <i class="fa-solid fa-lock"></i> Preço Máximo
        </button>
        <button class="section-tab" :class="{ 'active': activeSection === 'miles' }" @click="activeSection = 'miles'">
          <i class="fa-solid fa-box"></i> Estoque
        </button>
      </div>

      <!-- Price Tables Section -->
      <div class="section" x-show="activeSection === 'prices'">
        <div class="section-header">
          <h2><i class="fa-solid fa-chart-simple"></i> Tabela de Preços</h2>
        </div>
        <p class="section-description">
          Configure os preços por quantidade (em milhares). Ex: 15 = 15k milhas
        </p>

        <!-- Price Type Tabs (only when has liminar - mobile only) -->
        <div class="price-type-tabs" x-show="hasLiminar()">
          <button class="price-type-tab" :class="{ 'active': priceTypeTab === 'normal' }"
            @click="priceTypeTab = 'normal'">
            Normal
          </button>
          <button class="price-type-tab" :class="{ 'active': priceTypeTab === 'liminar' }"
            @click="priceTypeTab = 'liminar'">
            Liminar
          </button>
        </div>

        <template x-for="prog in programsToShow" :key="prog.id">
          <div class="price-carousel-wrapper" x-show="shouldShowPriceProgram(prog)" style="margin-bottom: 16px;">
            <h4 class="price-program-header" x-show="!hasLiminar()">
              <span x-text="prog.name"></span>
              <span x-show="prog.isLiminar" class="liminar-badge">LIMINAR</span>
            </h4>

            <!-- Price Cards -->
            <template x-if="getPriceEntries(prog.id).length > 0">
              <div class="price-cards-list">
                <template x-for="(entry, i) in getPriceEntries(prog.id)" :key="i">
                  <div class="data-card price-data-card" :data-program-id="prog.id">
                    <div class="data-card-header">
                      <span class="data-card-badge" x-text="`${entry.quantity || 0}k`"></span>
                      <div class="data-card-actions">
                        <button class="data-card-save" @click="saveSinglePriceEntry(prog.id, i)"
                          :disabled="!isValidPriceEntry(entry) || savingEntryIndex === i"
                          x-show="isValidPriceEntry(entry)">
                          <span x-show="savingEntryIndex === i" class="spinner" style="width: 14px; height: 14px;"></span>
                          <span x-show="savingEntryIndex !== i"><i class="fa-solid fa-check"></i></span>
                        </button>
                        <button class="data-card-delete" @click="removePriceEntry(prog.id, i)"><i class="fa-solid fa-xmark"></i></button>
                      </div>
                    </div>
                    <div class="data-card-fields">
                      <div class="data-card-field">
                        <label>Quantidade (k)</label>
                        <input type="number" x-model.number="entry.quantity" @input="markAsChanged()" step="1" min="1"
                          placeholder="15">
                      </div>
                      <div class="data-card-field">
                        <label>Preço (R$)</label>
                        <input type="number" x-model.number="entry.price" @input="markAsChanged()" step="0.25" min="0"
                          placeholder="20.00">
                      </div>
                    </div>
                  </div>
                </template>
              </div>
            </template>

            <!-- Empty state message -->
            <template x-if="getPriceEntries(prog.id).length === 0">
              <div class="empty-state" style="text-align: center; padding: 20px; color: #666;">
                <p>Nenhum preço cadastrado. Clique em "Adicionar Preço" para começar.</p>
              </div>
            </template>

            <button class="add-card-btn" @click="addPriceEntry(prog.id)">+ Adicionar Preço</button>
          </div>
        </template>

      </div>

      <!-- Max Prices Section -->
      <div class="section" x-show="activeSection === 'maxPrices'">
        <div class="section-header">
          <h2><i class="fa-solid fa-lock"></i> Preço Máximo (PREÇO TETO)</h2>
        </div>
        <p class="section-description">
          Define o preço máximo que será cobrado para cada programa
        </p>

        <div class="data-cards">
          <template x-for="prog in programsToShow" :key="prog.id">
            <div class="data-card maxprice-data-card" :data-program-id="prog.id">
              <div class="data-card-header">
                <span class="data-card-title">
                  <span x-text="prog.name"></span>
                  <span x-show="prog.isLiminar" class="liminar-badge">LIMINAR</span>
                </span>
              </div>
              <div class="data-card-fields">
                <div class="data-card-field" style="flex: 1;">
                  <label>Preço Máximo (R$)</label>
                  <input type="number" :value="getMaxPrice(prog.id)?.maxPrice || ''"
                    @input="updateMaxPrice(prog.id, $event.target.value)" step="0.25" min="0" placeholder="Sem limite">
                </div>
              </div>
            </div>
          </template>
        </div>

        <div class="btn-group">
          <button type="button" class="btn btn-primary" @click="saveMaxPrices()" :disabled="saving">
            <span x-show="saving" class="spinner" style="width: 14px; height: 14px; margin-right: 8px;"></span>
            Salvar Preços Máximos
          </button>
        </div>
      </div>

      <!-- Available Miles Section -->
      <div class="section" x-show="activeSection === 'miles'">
        <div class="section-header">
          <h2><i class="fa-solid fa-box"></i> Estoque de Milhas</h2>
        </div>
        <p class="section-description">
          Configure a quantidade de milhas disponíveis para cada programa
        </p>

        <div class="data-cards">
          <template x-for="prog in programsToShow" :key="prog.id">
            <div class="data-card miles-data-card" :data-program-id="prog.id">
              <div class="data-card-header">
                <span class="data-card-title">
                  <span x-text="prog.name"></span>
                  <span x-show="prog.isLiminar" class="liminar-badge">LIMINAR</span>
                </span>
              </div>
              <div class="data-card-fields">
                <div class="data-card-field" style="flex: 1;">
                  <label>Milhas Disponíveis</label>
                  <input type="number" :value="getMiles(prog.id)?.availableMiles || ''"
                    @input="updateMiles(prog.id, $event.target.value)" step="1000" min="0" placeholder="0">
                </div>
              </div>
            </div>
          </template>
        </div>

        <div class="btn-group">
          <button type="button" class="btn btn-primary" @click="saveMiles()" :disabled="saving">
            <span x-show="saving" class="spinner" style="width: 14px; height: 14px; margin-right: 8px;"></span>
            Salvar Estoque
          </button>
        </div>
      </div>
    </div>

    <!-- Bottom Sheet Overlay -->
    <div class="bottom-sheet-overlay" :class="{ 'visible': bottomSheetOpen }" @click="closeBottomSheet()"></div>

    <!-- Bottom Sheet -->
    <div class="bottom-sheet" :class="{ 'visible': bottomSheetOpen }">
      <div class="bottom-sheet-header">
        <h3>Selecionar Programa</h3>
        <button class="bottom-sheet-close" @click="closeBottomSheet()"><i class="fa-solid fa-xmark"></i></button>
      </div>
      <div style="padding: 20px 16px;">
        <input type="search" class="bottom-sheet-search" placeholder="Buscar programa..." x-model="programSearch">
      </div>
      <div class="bottom-sheet-content">
        <template x-for="p in filteredPrograms" :key="p.id">
          <div class="program-list-item" :class="{ 'active': selectedProgramId === p.id }"
            @click="selectProgramFromSheet(p.id)">
            <div>
              <div class="program-list-item-name" x-text="p.name"></div>
              <div class="program-list-item-stats"
                x-text="`${getPriceCount(p.id)} preços • ${getMilesDisplay(p.id)} milhas`">
              </div>
            </div>
          </div>
        </template>
      </div>
    </div>

    <!-- Toast Notification -->
    <div class="toast"
      :class="{ 'visible': toast.visible, 'success': toast.type === 'success', 'error': toast.type === 'error' }"
      x-text="toast.message">
    </div>
  </div>
  <script>
    function dashboard() {
      return {
        // ============================================================================
        // State
        // ============================================================================
        programs: [],
        userData: { priceEntries: [], maxPrices: [], availableMiles: [] },
        selectedProgramId: null,
        hasUnsavedChanges: false,
        showOverview: false,
        loading: true,
        saving: false,
        errorMessage: null,
        carouselIndex: {},

        // Toast state
        toast: { visible: false, message: '', type: 'success' },

        // Bottom sheet state
        bottomSheetOpen: false,
        programSearch: '',

        // Swipe state
        touchStartX: 0,
        touchStartY: 0,

        // Section tabs state
        activeSection: 'prices', // 'prices' | 'maxPrices' | 'miles'

        // Price type tab state (for mobile normal/liminar tabs)
        priceTypeTab: 'normal', // 'normal' | 'liminar'

        // Individual save state
        savingEntryIndex: null,

        // Timer state
        expiresAt: null,
        countdownDisplay: '--:--',
        timerWarning: false,
        timerExpired: false,
        countdownInterval: null,

        // ============================================================================
        // Computed Properties (as getters)
        // ============================================================================
        get token() {
          const parts = window.location.pathname.split('/');
          return parts[parts.length - 1];
        },

        get normalPrograms() {
          return this.programs.filter(p => !p.isLiminar);
        },

        get selectedProgram() {
          return this.programs.find(p => p.id === this.selectedProgramId);
        },

        get filteredPrograms() {
          const q = this.programSearch.toLowerCase();
          return q ? this.normalPrograms.filter(p => p.name.toLowerCase().includes(q)) : this.normalPrograms;
        },

        get programsToShow() {
          const program = this.selectedProgram;
          if (!program) return [];
          const liminar = this.programs.find(p => p.liminarOfId === program.id);
          return liminar ? [program, liminar] : [program];
        },

        // Returns only the program for the selected price type tab (mobile)
        get currentPriceProgram() {
          const program = this.selectedProgram;
          if (!program) return [];

          const liminar = this.programs.find(p => p.liminarOfId === program.id);

          // Se não tem liminar, retorna só o programa normal
          if (!liminar) return [program];

          // Retorna baseado na aba selecionada
          return this.priceTypeTab === 'liminar' ? [liminar] : [program];
        },

        get currentProgramIndex() {
          return this.normalPrograms.findIndex(p => p.id === this.selectedProgramId);
        },

        // ============================================================================
        // Initialization
        // ============================================================================
        async init() {
          try {
            const statusRes = await fetch(`/dashboard/${this.token}/status`);
            const status = await statusRes.json();

            if (!status.valid) {
              this.errorMessage = 'Este link expirou ou é inválido. Por favor, solicite um novo link no bot.';
              return;
            }

            // Capturar expiresAt e iniciar countdown
            if (status.expiresAt) {
              this.expiresAt = new Date(status.expiresAt).getTime();
              this.startCountdown();
            }

            await Promise.all([this.fetchPrograms(), this.fetchUserData()]);

            if (this.normalPrograms.length > 0) {
              this.selectedProgramId = this.normalPrograms[0].id;
            }

            this.loading = false;
          } catch (error) {
            console.error('Initialization error:', error);
            this.errorMessage = error.message;
          }
        },

        // ============================================================================
        // API Methods
        // ============================================================================
        async fetchPrograms() {
          const res = await fetch(`/dashboard/${this.token}/programs`);
          const data = await res.json();
          if (data.success) {
            this.programs = data.data;
          } else {
            throw new Error(data.error || 'Failed to fetch programs');
          }
        },

        async fetchUserData() {
          const res = await fetch(`/dashboard/${this.token}/data`);
          const data = await res.json();
          if (data.success) {
            this.userData = data.data;
          } else {
            throw new Error(data.error || 'Failed to fetch user data');
          }
        },

        async savePricesApi(entries) {
          const res = await fetch(`/dashboard/${this.token}/prices`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ entries }),
          });
          const data = await res.json();
          if (!data.success) {
            throw new Error(data.error || 'Failed to save prices');
          }
          return data;
        },

        async saveSinglePriceApi(entry) {
          const res = await fetch(`/dashboard/${this.token}/price`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(entry),
          });
          const data = await res.json();
          if (!data.success) {
            throw new Error(data.error || 'Failed to save price');
          }
          return data;
        },

        async saveMaxPricesApi(maxPrices) {
          const res = await fetch(`/dashboard/${this.token}/max-prices`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ maxPrices }),
          });
          const data = await res.json();
          if (!data.success) {
            throw new Error(data.error || 'Failed to save max prices');
          }
          return data;
        },

        async saveMilesApi(miles) {
          const res = await fetch(`/dashboard/${this.token}/miles`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ miles }),
          });
          const data = await res.json();
          if (!data.success) {
            throw new Error(data.error || 'Failed to save miles');
          }
          return data;
        },

        // ============================================================================
        // Save Actions
        // ============================================================================
        async saveAll() {
          if (!this.hasUnsavedChanges) {
            this.showToast('Nenhuma alteração para salvar', 'success');
            return;
          }

          this.saving = true;

          try {
            const priceEntries = this.collectPriceEntries();
            if (priceEntries.length > 0) {
              await this.savePricesApi(priceEntries);
            }

            const maxPricesData = this.collectMaxPrices();
            if (maxPricesData.length > 0) {
              await this.saveMaxPricesApi(maxPricesData);
            }

            const milesData = this.collectMiles();
            if (milesData.length > 0) {
              await this.saveMilesApi(milesData);
            }

            await this.fetchUserData();
            this.hasUnsavedChanges = false;
            this.showToast('Tudo salvo com sucesso!', 'success');
          } catch (error) {
            this.showToast('Erro ao salvar: ' + error.message, 'error');
          } finally {
            this.saving = false;
          }
        },

        async savePrices() {
          this.saving = true;
          try {
            const entries = this.collectPriceEntries();
            await this.savePricesApi(entries);
            await this.fetchUserData();
            this.showToast('Preços salvos com sucesso!', 'success');
            this.hasUnsavedChanges = false;
          } catch (error) {
            this.showToast('Erro ao salvar: ' + error.message, 'error');
          } finally {
            this.saving = false;
          }
        },

        async saveSinglePriceEntry(programId, index) {
          const entries = this.getPriceEntries(programId);
          const entry = entries[index];

          if (!this.isValidPriceEntry(entry)) {
            this.showToast('Preencha quantidade e preço', 'error');
            return;
          }

          this.savingEntryIndex = index;

          try {
            await this.saveSinglePriceApi({
              programId: entry.programId,
              quantity: entry.quantity,
              price: entry.price,
            });
            this.showToast('Preço salvo!', 'success');
          } catch (error) {
            this.showToast('Erro ao salvar: ' + error.message, 'error');
          } finally {
            this.savingEntryIndex = null;
          }
        },

        async saveMaxPrices() {
          this.saving = true;
          try {
            const maxPrices = this.collectMaxPrices();
            await this.saveMaxPricesApi(maxPrices);
            await this.fetchUserData();
            this.showToast('Preços máximos salvos!', 'success');
            this.hasUnsavedChanges = false;
          } catch (error) {
            this.showToast('Erro ao salvar: ' + error.message, 'error');
          } finally {
            this.saving = false;
          }
        },

        async saveMiles() {
          this.saving = true;
          try {
            const miles = this.collectMiles();
            await this.saveMilesApi(miles);
            await this.fetchUserData();
            this.showToast('Estoque salvo!', 'success');
            this.hasUnsavedChanges = false;
          } catch (error) {
            this.showToast('Erro ao salvar: ' + error.message, 'error');
          } finally {
            this.saving = false;
          }
        },

        // ============================================================================
        // Data Collection
        // ============================================================================
        collectPriceEntries() {
          return this.userData.priceEntries
            .filter(e => e.quantity > 0 && e.price > 0)
            .map(e => ({ programId: e.programId, quantity: e.quantity, price: e.price }));
        },

        collectMaxPrices() {
          return this.userData.maxPrices
            .filter(mp => mp.maxPrice > 0)
            .map(mp => ({ programId: mp.programId, maxPrice: mp.maxPrice }));
        },

        collectMiles() {
          return this.userData.availableMiles
            .filter(m => m.availableMiles >= 0)
            .map(m => ({ programId: m.programId, availableMiles: m.availableMiles }));
        },

        // ============================================================================
        // Helper Methods
        // ============================================================================
        getPriceEntries(programId) {
          return this.userData.priceEntries.filter(e => e.programId === programId);
        },

        isValidPriceEntry(entry) {
          return entry.quantity > 0 && entry.price > 0;
        },

        getMaxPrice(programId) {
          return this.userData.maxPrices.find(mp => mp.programId === programId);
        },

        getMiles(programId) {
          return this.userData.availableMiles.find(am => am.programId === programId);
        },

        getPriceCount(programId) {
          return this.getPriceEntries(programId).length;
        },

        getMilesDisplay(programId) {
          const m = this.getMiles(programId);
          return m ? `${(m.availableMiles / 1000).toFixed(0)}k` : '0';
        },

        getMaxPriceDisplay(programId) {
          const mp = this.getMaxPrice(programId);
          return mp ? `R$ ${mp.maxPrice.toFixed(2)}` : null;
        },

        hasLiminar() {
          const program = this.selectedProgram;
          if (!program) return false;
          return this.programs.some(p => p.liminarOfId === program.id);
        },

        // Determines if a program should be shown in the price section (tabs logic)
        shouldShowPriceProgram(prog) {
          // If no liminar exists for current program, always show
          if (!this.hasLiminar()) return true;

          // Show based on selected tab
          return this.priceTypeTab === 'liminar' ? prog.isLiminar : !prog.isLiminar;
        },

        // ============================================================================
        // Program Selection
        // ============================================================================
        selectProgram(programId) {
          this.selectedProgramId = programId;
          // Reset price type tab to normal when changing programs
          this.priceTypeTab = 'normal';
          // Scroll active pill into view
          this.$nextTick(() => {
            const activePill = document.querySelector('.pill.active');
            if (activePill) {
              activePill.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
            }
          });
        },

        // ============================================================================
        // Price Entry Management
        // ============================================================================
        addPriceEntry(programId) {
          this.userData.priceEntries.push({
            programId,
            programName: this.programs.find(p => p.id === programId)?.name ?? '',
            quantity: 0,
            price: 0,
          });
          this.hasUnsavedChanges = true;

          // Update carousel to show the new card
          const entries = this.getPriceEntries(programId);
          this.carouselIndex[programId] = entries.length - 1;
        },

        removePriceEntry(programId, index) {
          const entries = this.getPriceEntries(programId);
          const globalIndex = this.userData.priceEntries.indexOf(entries[index]);
          if (globalIndex > -1) {
            this.userData.priceEntries.splice(globalIndex, 1);
            this.hasUnsavedChanges = true;

            // Adjust carousel index
            const currentIndex = this.carouselIndex[programId] || 0;
            if (currentIndex >= entries.length - 1) {
              this.carouselIndex[programId] = Math.max(0, entries.length - 2);
            }
          }
        },

        // ============================================================================
        // Max Price Management
        // ============================================================================
        ensureMaxPriceEntry(programId) {
          let entry = this.userData.maxPrices.find(mp => mp.programId === programId);
          if (!entry) {
            entry = {
              programId,
              programName: this.programs.find(p => p.id === programId)?.name ?? '',
              maxPrice: 0,
            };
            this.userData.maxPrices.push(entry);
          }
          return entry;
        },

        updateMaxPrice(programId, value) {
          const entry = this.ensureMaxPriceEntry(programId);
          entry.maxPrice = parseFloat(value) || 0;
          this.hasUnsavedChanges = true;
        },

        // ============================================================================
        // Miles Management
        // ============================================================================
        ensureMilesEntry(programId) {
          let entry = this.userData.availableMiles.find(am => am.programId === programId);
          if (!entry) {
            entry = {
              programId,
              programName: this.programs.find(p => p.id === programId)?.name ?? '',
              availableMiles: 0,
            };
            this.userData.availableMiles.push(entry);
          }
          return entry;
        },

        updateMiles(programId, value) {
          const entry = this.ensureMilesEntry(programId);
          entry.availableMiles = parseInt(value) || 0;
          this.hasUnsavedChanges = true;
        },

        // ============================================================================
        // Carousel
        // ============================================================================
        getCarouselIndex(programId) {
          if (this.carouselIndex[programId] === undefined) {
            this.carouselIndex[programId] = 0;
          }
          const entries = this.getPriceEntries(programId);
          const maxIndex = Math.max(0, entries.length - 1);
          if (this.carouselIndex[programId] > maxIndex) {
            this.carouselIndex[programId] = maxIndex;
          }
          return this.carouselIndex[programId];
        },

        setCarouselIndex(programId, index) {
          this.carouselIndex[programId] = index;
        },

        nextCarousel(programId) {
          const entries = this.getPriceEntries(programId);
          const current = this.getCarouselIndex(programId);
          if (current < entries.length - 1) {
            this.carouselIndex[programId] = current + 1;
          }
        },

        prevCarousel(programId) {
          const current = this.getCarouselIndex(programId);
          if (current > 0) {
            this.carouselIndex[programId] = current - 1;
          }
        },

        // ============================================================================
        // Toast
        // ============================================================================
        showToast(message, type = 'success') {
          this.toast = { visible: true, message, type };
          setTimeout(() => {
            this.toast.visible = false;
          }, 3000);
        },

        // ============================================================================
        // Overview Mode
        // ============================================================================
        toggleOverview() {
          this.showOverview = !this.showOverview;
        },

        selectProgramFromOverview(programId) {
          this.selectProgram(programId);
          this.showOverview = false;
        },

        // ============================================================================
        // Bottom Sheet
        // ============================================================================
        openBottomSheet() {
          this.programSearch = '';
          this.bottomSheetOpen = true;
        },

        closeBottomSheet() {
          this.bottomSheetOpen = false;
        },

        selectProgramFromSheet(programId) {
          this.selectProgram(programId);
          this.closeBottomSheet();
        },

        // ============================================================================
        // Timer / Countdown
        // ============================================================================
        formatTime(seconds) {
          const mins = Math.floor(seconds / 60);
          const secs = seconds % 60;
          return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        },

        updateCountdown() {
          if (!this.expiresAt) return;

          const now = Date.now();
          const remaining = Math.max(0, Math.floor((this.expiresAt - now) / 1000));

          this.countdownDisplay = this.formatTime(remaining);
          this.timerWarning = remaining <= 60 && remaining > 0;
          this.timerExpired = remaining <= 0;

          if (remaining <= 0 && this.countdownInterval) {
            clearInterval(this.countdownInterval);
          }
        },

        startCountdown() {
          this.updateCountdown();
          this.countdownInterval = setInterval(() => this.updateCountdown(), 1000);
        },

        // ============================================================================
        // Swipe Gestures
        // ============================================================================
        onTouchStart(e) {
          this.touchStartX = e.touches[0].clientX;
          this.touchStartY = e.touches[0].clientY;
        },

        onTouchEnd(e) {
          const diffX = this.touchStartX - e.changedTouches[0].clientX;
          const diffY = this.touchStartY - e.changedTouches[0].clientY;

          if (Math.abs(diffX) > 80 && Math.abs(diffX) > Math.abs(diffY) * 2) {
            this.navigateProgram(diffX > 0 ? 1 : -1);
          }
        },

        navigateProgram(direction) {
          const currentIndex = this.currentProgramIndex;
          if (currentIndex === -1) return;

          const newIndex = currentIndex + direction;

          if (newIndex >= 0 && newIndex < this.normalPrograms.length) {
            this.selectProgram(this.normalPrograms[newIndex].id);
          }
        },

        // ============================================================================
        // Utility
        // ============================================================================
        isMobile() {
          return window.innerWidth <= 768;
        },

        markAsChanged() {
          this.hasUnsavedChanges = true;
        },
      };
    }
  </script>
</body>

</html>